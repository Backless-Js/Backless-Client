{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst path = require('path');\n\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10;\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5;\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0;\nconst nodeVersion = process.versions.node.split('.');\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);\n\nfunction nodeSupportsBigInt() {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true;\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true;\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction getStats(src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, {\n      bigint: true\n    }, (err, srcStat) => {\n      if (err) return cb(err);\n      fs.stat(dest, {\n        bigint: true\n      }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, {\n            srcStat,\n            destStat: null\n          });\n          return cb(err);\n        }\n\n        return cb(null, {\n          srcStat,\n          destStat\n        });\n      });\n    });\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err);\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, {\n            srcStat,\n            destStat: null\n          });\n          return cb(err);\n        }\n\n        return cb(null, {\n          srcStat,\n          destStat\n        });\n      });\n    });\n  }\n}\n\nfunction getStatsSync(src, dest) {\n  let srcStat, destStat;\n\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, {\n      bigint: true\n    });\n  } else {\n    srcStat = fs.statSync(src);\n  }\n\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, {\n        bigint: true\n      });\n    } else {\n      destStat = fs.statSync(dest);\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return {\n      srcStat,\n      destStat: null\n    };\n    throw err;\n  }\n\n  return {\n    srcStat,\n    destStat\n  };\n}\n\nfunction checkPaths(src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err);\n    const {\n      srcStat,\n      destStat\n    } = stats;\n\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'));\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n\n    return cb(null, {\n      srcStat,\n      destStat\n    });\n  });\n}\n\nfunction checkPathsSync(src, dest, funcName) {\n  const {\n    srcStat,\n    destStat\n  } = getStatsSync(src, dest);\n\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.');\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n\n  return {\n    srcStat,\n    destStat\n  };\n} // recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\n\n\nfunction checkParentPaths(src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();\n\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, {\n      bigint: true\n    }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb();\n        return cb(err);\n      }\n\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)));\n      }\n\n      return checkParentPaths(src, srcStat, destParent, funcName, cb);\n    });\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb();\n        return cb(err);\n      }\n\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)));\n      }\n\n      return checkParentPaths(src, srcStat, destParent, funcName, cb);\n    });\n  }\n}\n\nfunction checkParentPathsSync(src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return;\n  let destStat;\n\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, {\n        bigint: true\n      });\n    } else {\n      destStat = fs.statSync(destParent);\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return;\n    throw err;\n  }\n\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n\n  return checkParentPathsSync(src, srcStat, destParent, funcName);\n} // return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\n\n\nfunction isSrcSubdir(src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i);\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i);\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);\n}\n\nfunction errMsg(src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n};","map":{"version":3,"sources":["/home/marcel/Desktop/CobaProject/GUI backless-js/axsis/node_modules/fs-extra/lib/util/stat.js"],"names":["fs","require","path","NODE_VERSION_MAJOR_WITH_BIGINT","NODE_VERSION_MINOR_WITH_BIGINT","NODE_VERSION_PATCH_WITH_BIGINT","nodeVersion","process","versions","node","split","nodeVersionMajor","Number","parseInt","nodeVersionMinor","nodeVersionPatch","nodeSupportsBigInt","getStats","src","dest","cb","stat","bigint","err","srcStat","destStat","code","getStatsSync","statSync","checkPaths","funcName","stats","ino","dev","Error","isDirectory","isSrcSubdir","errMsg","checkPathsSync","checkParentPaths","srcParent","resolve","dirname","destParent","parse","root","checkParentPathsSync","srcArr","sep","filter","i","destArr","reduce","acc","cur","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,aAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAME,8BAA8B,GAAG,EAAvC;AACA,MAAMC,8BAA8B,GAAG,CAAvC;AACA,MAAMC,8BAA8B,GAAG,CAAvC;AACA,MAAMC,WAAW,GAAGC,OAAO,CAACC,QAAR,CAAiBC,IAAjB,CAAsBC,KAAtB,CAA4B,GAA5B,CAApB;AACA,MAAMC,gBAAgB,GAAGC,MAAM,CAACC,QAAP,CAAgBP,WAAW,CAAC,CAAD,CAA3B,EAAgC,EAAhC,CAAzB;AACA,MAAMQ,gBAAgB,GAAGF,MAAM,CAACC,QAAP,CAAgBP,WAAW,CAAC,CAAD,CAA3B,EAAgC,EAAhC,CAAzB;AACA,MAAMS,gBAAgB,GAAGH,MAAM,CAACC,QAAP,CAAgBP,WAAW,CAAC,CAAD,CAA3B,EAAgC,EAAhC,CAAzB;;AAEA,SAASU,kBAAT,GAA+B;AAC7B,MAAIL,gBAAgB,GAAGR,8BAAvB,EAAuD;AACrD,WAAO,IAAP;AACD,GAFD,MAEO,IAAIQ,gBAAgB,KAAKR,8BAAzB,EAAyD;AAC9D,QAAIW,gBAAgB,GAAGV,8BAAvB,EAAuD;AACrD,aAAO,IAAP;AACD,KAFD,MAEO,IAAIU,gBAAgB,KAAKV,8BAAzB,EAAyD;AAC9D,UAAIW,gBAAgB,IAAIV,8BAAxB,EAAwD;AACtD,eAAO,IAAP;AACD;AACF;AACF;;AACD,SAAO,KAAP;AACD;;AAED,SAASY,QAAT,CAAmBC,GAAnB,EAAwBC,IAAxB,EAA8BC,EAA9B,EAAkC;AAChC,MAAIJ,kBAAkB,EAAtB,EAA0B;AACxBhB,IAAAA,EAAE,CAACqB,IAAH,CAAQH,GAAR,EAAa;AAAEI,MAAAA,MAAM,EAAE;AAAV,KAAb,EAA+B,CAACC,GAAD,EAAMC,OAAN,KAAkB;AAC/C,UAAID,GAAJ,EAAS,OAAOH,EAAE,CAACG,GAAD,CAAT;AACTvB,MAAAA,EAAE,CAACqB,IAAH,CAAQF,IAAR,EAAc;AAAEG,QAAAA,MAAM,EAAE;AAAV,OAAd,EAAgC,CAACC,GAAD,EAAME,QAAN,KAAmB;AACjD,YAAIF,GAAJ,EAAS;AACP,cAAIA,GAAG,CAACG,IAAJ,KAAa,QAAjB,EAA2B,OAAON,EAAE,CAAC,IAAD,EAAO;AAAEI,YAAAA,OAAF;AAAWC,YAAAA,QAAQ,EAAE;AAArB,WAAP,CAAT;AAC3B,iBAAOL,EAAE,CAACG,GAAD,CAAT;AACD;;AACD,eAAOH,EAAE,CAAC,IAAD,EAAO;AAAEI,UAAAA,OAAF;AAAWC,UAAAA;AAAX,SAAP,CAAT;AACD,OAND;AAOD,KATD;AAUD,GAXD,MAWO;AACLzB,IAAAA,EAAE,CAACqB,IAAH,CAAQH,GAAR,EAAa,CAACK,GAAD,EAAMC,OAAN,KAAkB;AAC7B,UAAID,GAAJ,EAAS,OAAOH,EAAE,CAACG,GAAD,CAAT;AACTvB,MAAAA,EAAE,CAACqB,IAAH,CAAQF,IAAR,EAAc,CAACI,GAAD,EAAME,QAAN,KAAmB;AAC/B,YAAIF,GAAJ,EAAS;AACP,cAAIA,GAAG,CAACG,IAAJ,KAAa,QAAjB,EAA2B,OAAON,EAAE,CAAC,IAAD,EAAO;AAAEI,YAAAA,OAAF;AAAWC,YAAAA,QAAQ,EAAE;AAArB,WAAP,CAAT;AAC3B,iBAAOL,EAAE,CAACG,GAAD,CAAT;AACD;;AACD,eAAOH,EAAE,CAAC,IAAD,EAAO;AAAEI,UAAAA,OAAF;AAAWC,UAAAA;AAAX,SAAP,CAAT;AACD,OAND;AAOD,KATD;AAUD;AACF;;AAED,SAASE,YAAT,CAAuBT,GAAvB,EAA4BC,IAA5B,EAAkC;AAChC,MAAIK,OAAJ,EAAaC,QAAb;;AACA,MAAIT,kBAAkB,EAAtB,EAA0B;AACxBQ,IAAAA,OAAO,GAAGxB,EAAE,CAAC4B,QAAH,CAAYV,GAAZ,EAAiB;AAAEI,MAAAA,MAAM,EAAE;AAAV,KAAjB,CAAV;AACD,GAFD,MAEO;AACLE,IAAAA,OAAO,GAAGxB,EAAE,CAAC4B,QAAH,CAAYV,GAAZ,CAAV;AACD;;AACD,MAAI;AACF,QAAIF,kBAAkB,EAAtB,EAA0B;AACxBS,MAAAA,QAAQ,GAAGzB,EAAE,CAAC4B,QAAH,CAAYT,IAAZ,EAAkB;AAAEG,QAAAA,MAAM,EAAE;AAAV,OAAlB,CAAX;AACD,KAFD,MAEO;AACLG,MAAAA,QAAQ,GAAGzB,EAAE,CAAC4B,QAAH,CAAYT,IAAZ,CAAX;AACD;AACF,GAND,CAME,OAAOI,GAAP,EAAY;AACZ,QAAIA,GAAG,CAACG,IAAJ,KAAa,QAAjB,EAA2B,OAAO;AAAEF,MAAAA,OAAF;AAAWC,MAAAA,QAAQ,EAAE;AAArB,KAAP;AAC3B,UAAMF,GAAN;AACD;;AACD,SAAO;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,GAAP;AACD;;AAED,SAASI,UAAT,CAAqBX,GAArB,EAA0BC,IAA1B,EAAgCW,QAAhC,EAA0CV,EAA1C,EAA8C;AAC5CH,EAAAA,QAAQ,CAACC,GAAD,EAAMC,IAAN,EAAY,CAACI,GAAD,EAAMQ,KAAN,KAAgB;AAClC,QAAIR,GAAJ,EAAS,OAAOH,EAAE,CAACG,GAAD,CAAT;AACT,UAAM;AAAEC,MAAAA,OAAF;AAAWC,MAAAA;AAAX,QAAwBM,KAA9B;;AACA,QAAIN,QAAQ,IAAIA,QAAQ,CAACO,GAArB,IAA4BP,QAAQ,CAACQ,GAArC,IAA4CR,QAAQ,CAACO,GAAT,KAAiBR,OAAO,CAACQ,GAArE,IAA4EP,QAAQ,CAACQ,GAAT,KAAiBT,OAAO,CAACS,GAAzG,EAA8G;AAC5G,aAAOb,EAAE,CAAC,IAAIc,KAAJ,CAAU,8CAAV,CAAD,CAAT;AACD;;AACD,QAAIV,OAAO,CAACW,WAAR,MAAyBC,WAAW,CAAClB,GAAD,EAAMC,IAAN,CAAxC,EAAqD;AACnD,aAAOC,EAAE,CAAC,IAAIc,KAAJ,CAAUG,MAAM,CAACnB,GAAD,EAAMC,IAAN,EAAYW,QAAZ,CAAhB,CAAD,CAAT;AACD;;AACD,WAAOV,EAAE,CAAC,IAAD,EAAO;AAAEI,MAAAA,OAAF;AAAWC,MAAAA;AAAX,KAAP,CAAT;AACD,GAVO,CAAR;AAWD;;AAED,SAASa,cAAT,CAAyBpB,GAAzB,EAA8BC,IAA9B,EAAoCW,QAApC,EAA8C;AAC5C,QAAM;AAAEN,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAwBE,YAAY,CAACT,GAAD,EAAMC,IAAN,CAA1C;;AACA,MAAIM,QAAQ,IAAIA,QAAQ,CAACO,GAArB,IAA4BP,QAAQ,CAACQ,GAArC,IAA4CR,QAAQ,CAACO,GAAT,KAAiBR,OAAO,CAACQ,GAArE,IAA4EP,QAAQ,CAACQ,GAAT,KAAiBT,OAAO,CAACS,GAAzG,EAA8G;AAC5G,UAAM,IAAIC,KAAJ,CAAU,8CAAV,CAAN;AACD;;AACD,MAAIV,OAAO,CAACW,WAAR,MAAyBC,WAAW,CAAClB,GAAD,EAAMC,IAAN,CAAxC,EAAqD;AACnD,UAAM,IAAIe,KAAJ,CAAUG,MAAM,CAACnB,GAAD,EAAMC,IAAN,EAAYW,QAAZ,CAAhB,CAAN;AACD;;AACD,SAAO;AAAEN,IAAAA,OAAF;AAAWC,IAAAA;AAAX,GAAP;AACD,C,CAED;AACA;AACA;AACA;;;AACA,SAASc,gBAAT,CAA2BrB,GAA3B,EAAgCM,OAAhC,EAAyCL,IAAzC,EAA+CW,QAA/C,EAAyDV,EAAzD,EAA6D;AAC3D,QAAMoB,SAAS,GAAGtC,IAAI,CAACuC,OAAL,CAAavC,IAAI,CAACwC,OAAL,CAAaxB,GAAb,CAAb,CAAlB;AACA,QAAMyB,UAAU,GAAGzC,IAAI,CAACuC,OAAL,CAAavC,IAAI,CAACwC,OAAL,CAAavB,IAAb,CAAb,CAAnB;AACA,MAAIwB,UAAU,KAAKH,SAAf,IAA4BG,UAAU,KAAKzC,IAAI,CAAC0C,KAAL,CAAWD,UAAX,EAAuBE,IAAtE,EAA4E,OAAOzB,EAAE,EAAT;;AAC5E,MAAIJ,kBAAkB,EAAtB,EAA0B;AACxBhB,IAAAA,EAAE,CAACqB,IAAH,CAAQsB,UAAR,EAAoB;AAAErB,MAAAA,MAAM,EAAE;AAAV,KAApB,EAAsC,CAACC,GAAD,EAAME,QAAN,KAAmB;AACvD,UAAIF,GAAJ,EAAS;AACP,YAAIA,GAAG,CAACG,IAAJ,KAAa,QAAjB,EAA2B,OAAON,EAAE,EAAT;AAC3B,eAAOA,EAAE,CAACG,GAAD,CAAT;AACD;;AACD,UAAIE,QAAQ,CAACO,GAAT,IAAgBP,QAAQ,CAACQ,GAAzB,IAAgCR,QAAQ,CAACO,GAAT,KAAiBR,OAAO,CAACQ,GAAzD,IAAgEP,QAAQ,CAACQ,GAAT,KAAiBT,OAAO,CAACS,GAA7F,EAAkG;AAChG,eAAOb,EAAE,CAAC,IAAIc,KAAJ,CAAUG,MAAM,CAACnB,GAAD,EAAMC,IAAN,EAAYW,QAAZ,CAAhB,CAAD,CAAT;AACD;;AACD,aAAOS,gBAAgB,CAACrB,GAAD,EAAMM,OAAN,EAAemB,UAAf,EAA2Bb,QAA3B,EAAqCV,EAArC,CAAvB;AACD,KATD;AAUD,GAXD,MAWO;AACLpB,IAAAA,EAAE,CAACqB,IAAH,CAAQsB,UAAR,EAAoB,CAACpB,GAAD,EAAME,QAAN,KAAmB;AACrC,UAAIF,GAAJ,EAAS;AACP,YAAIA,GAAG,CAACG,IAAJ,KAAa,QAAjB,EAA2B,OAAON,EAAE,EAAT;AAC3B,eAAOA,EAAE,CAACG,GAAD,CAAT;AACD;;AACD,UAAIE,QAAQ,CAACO,GAAT,IAAgBP,QAAQ,CAACQ,GAAzB,IAAgCR,QAAQ,CAACO,GAAT,KAAiBR,OAAO,CAACQ,GAAzD,IAAgEP,QAAQ,CAACQ,GAAT,KAAiBT,OAAO,CAACS,GAA7F,EAAkG;AAChG,eAAOb,EAAE,CAAC,IAAIc,KAAJ,CAAUG,MAAM,CAACnB,GAAD,EAAMC,IAAN,EAAYW,QAAZ,CAAhB,CAAD,CAAT;AACD;;AACD,aAAOS,gBAAgB,CAACrB,GAAD,EAAMM,OAAN,EAAemB,UAAf,EAA2Bb,QAA3B,EAAqCV,EAArC,CAAvB;AACD,KATD;AAUD;AACF;;AAED,SAAS0B,oBAAT,CAA+B5B,GAA/B,EAAoCM,OAApC,EAA6CL,IAA7C,EAAmDW,QAAnD,EAA6D;AAC3D,QAAMU,SAAS,GAAGtC,IAAI,CAACuC,OAAL,CAAavC,IAAI,CAACwC,OAAL,CAAaxB,GAAb,CAAb,CAAlB;AACA,QAAMyB,UAAU,GAAGzC,IAAI,CAACuC,OAAL,CAAavC,IAAI,CAACwC,OAAL,CAAavB,IAAb,CAAb,CAAnB;AACA,MAAIwB,UAAU,KAAKH,SAAf,IAA4BG,UAAU,KAAKzC,IAAI,CAAC0C,KAAL,CAAWD,UAAX,EAAuBE,IAAtE,EAA4E;AAC5E,MAAIpB,QAAJ;;AACA,MAAI;AACF,QAAIT,kBAAkB,EAAtB,EAA0B;AACxBS,MAAAA,QAAQ,GAAGzB,EAAE,CAAC4B,QAAH,CAAYe,UAAZ,EAAwB;AAAErB,QAAAA,MAAM,EAAE;AAAV,OAAxB,CAAX;AACD,KAFD,MAEO;AACLG,MAAAA,QAAQ,GAAGzB,EAAE,CAAC4B,QAAH,CAAYe,UAAZ,CAAX;AACD;AACF,GAND,CAME,OAAOpB,GAAP,EAAY;AACZ,QAAIA,GAAG,CAACG,IAAJ,KAAa,QAAjB,EAA2B;AAC3B,UAAMH,GAAN;AACD;;AACD,MAAIE,QAAQ,CAACO,GAAT,IAAgBP,QAAQ,CAACQ,GAAzB,IAAgCR,QAAQ,CAACO,GAAT,KAAiBR,OAAO,CAACQ,GAAzD,IAAgEP,QAAQ,CAACQ,GAAT,KAAiBT,OAAO,CAACS,GAA7F,EAAkG;AAChG,UAAM,IAAIC,KAAJ,CAAUG,MAAM,CAACnB,GAAD,EAAMC,IAAN,EAAYW,QAAZ,CAAhB,CAAN;AACD;;AACD,SAAOgB,oBAAoB,CAAC5B,GAAD,EAAMM,OAAN,EAAemB,UAAf,EAA2Bb,QAA3B,CAA3B;AACD,C,CAED;AACA;;;AACA,SAASM,WAAT,CAAsBlB,GAAtB,EAA2BC,IAA3B,EAAiC;AAC/B,QAAM4B,MAAM,GAAG7C,IAAI,CAACuC,OAAL,CAAavB,GAAb,EAAkBR,KAAlB,CAAwBR,IAAI,CAAC8C,GAA7B,EAAkCC,MAAlC,CAAyCC,CAAC,IAAIA,CAA9C,CAAf;AACA,QAAMC,OAAO,GAAGjD,IAAI,CAACuC,OAAL,CAAatB,IAAb,EAAmBT,KAAnB,CAAyBR,IAAI,CAAC8C,GAA9B,EAAmCC,MAAnC,CAA0CC,CAAC,IAAIA,CAA/C,CAAhB;AACA,SAAOH,MAAM,CAACK,MAAP,CAAc,CAACC,GAAD,EAAMC,GAAN,EAAWJ,CAAX,KAAiBG,GAAG,IAAIF,OAAO,CAACD,CAAD,CAAP,KAAeI,GAArD,EAA0D,IAA1D,CAAP;AACD;;AAED,SAASjB,MAAT,CAAiBnB,GAAjB,EAAsBC,IAAtB,EAA4BW,QAA5B,EAAsC;AACpC,SAAQ,UAASA,QAAS,KAAIZ,GAAI,mCAAkCC,IAAK,IAAzE;AACD;;AAEDoC,MAAM,CAACC,OAAP,GAAiB;AACf3B,EAAAA,UADe;AAEfS,EAAAA,cAFe;AAGfC,EAAAA,gBAHe;AAIfO,EAAAA,oBAJe;AAKfV,EAAAA;AALe,CAAjB","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\n\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0\nconst nodeVersion = process.versions.node.split('.')\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)\n\nfunction nodeSupportsBigInt () {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getStats (src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, { bigint: true }, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, { bigint: true }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  }\n}\n\nfunction getStatsSync (src, dest) {\n  let srcStat, destStat\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, { bigint: true })\n  } else {\n    srcStat = fs.statSync(src)\n  }\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, { bigint: true })\n    } else {\n      destStat = fs.statSync(dest)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, { bigint: true }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  }\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, { bigint: true })\n    } else {\n      destStat = fs.statSync(destParent)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n"]},"metadata":{},"sourceType":"script"}