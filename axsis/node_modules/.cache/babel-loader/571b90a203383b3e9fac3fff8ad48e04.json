{"ast":null,"code":"'use strict';\n\nvar stringWidth = require('string-width');\n\nvar stripAnsi = require('strip-ansi');\n\nvar ESCAPES = ['\\u001b', '\\u009b'];\nvar END_CODE = 39;\nvar ESCAPE_CODES = {\n  0: 0,\n  1: 22,\n  2: 22,\n  3: 23,\n  4: 24,\n  7: 27,\n  8: 28,\n  9: 29,\n  30: 39,\n  31: 39,\n  32: 39,\n  33: 39,\n  34: 39,\n  35: 39,\n  36: 39,\n  37: 39,\n  90: 39,\n  40: 49,\n  41: 49,\n  42: 49,\n  43: 49,\n  44: 49,\n  45: 49,\n  46: 49,\n  47: 49\n};\n\nfunction wrapAnsi(code) {\n  return ESCAPES[0] + '[' + code + 'm';\n} // calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes.\n\n\nfunction wordLengths(str) {\n  return str.split(' ').map(function (s) {\n    return stringWidth(s);\n  });\n} // wrap a long word across multiple rows.\n// ansi escape codes do not count towards length.\n\n\nfunction wrapWord(rows, word, cols) {\n  var insideEscape = false;\n  var visible = stripAnsi(rows[rows.length - 1]).length;\n\n  for (var i = 0; i < word.length; i++) {\n    var x = word[i];\n    rows[rows.length - 1] += x;\n\n    if (ESCAPES.indexOf(x) !== -1) {\n      insideEscape = true;\n    } else if (insideEscape && x === 'm') {\n      insideEscape = false;\n      continue;\n    }\n\n    if (insideEscape) {\n      continue;\n    }\n\n    visible++;\n\n    if (visible >= cols && i < word.length - 1) {\n      rows.push('');\n      visible = 0;\n    }\n  } // it's possible that the last row we copy over is only\n  // ansi escape characters, handle this edge-case.\n\n\n  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n    rows[rows.length - 2] += rows.pop();\n  }\n} // the wrap-ansi module can be invoked\n// in either 'hard' or 'soft' wrap mode.\n//\n// 'hard' will never allow a string to take up more\n// than cols characters.\n//\n// 'soft' allows long words to expand past the column length.\n\n\nfunction exec(str, cols, opts) {\n  var options = opts || {};\n  var pre = '';\n  var ret = '';\n  var escapeCode;\n  var lengths = wordLengths(str);\n  var words = str.split(' ');\n  var rows = [''];\n\n  for (var i = 0, word; (word = words[i]) !== undefined; i++) {\n    var rowLength = stringWidth(rows[rows.length - 1]);\n\n    if (rowLength) {\n      rows[rows.length - 1] += ' ';\n      rowLength++;\n    } // in 'hard' wrap mode, the length of a line is\n    // never allowed to extend past 'cols'.\n\n\n    if (lengths[i] > cols && options.hard) {\n      if (rowLength) {\n        rows.push('');\n      }\n\n      wrapWord(rows, word, cols);\n      continue;\n    }\n\n    if (rowLength + lengths[i] > cols && rowLength > 0) {\n      if (options.wordWrap === false && rowLength < cols) {\n        wrapWord(rows, word, cols);\n        continue;\n      }\n\n      rows.push('');\n    }\n\n    rows[rows.length - 1] += word;\n  }\n\n  pre = rows.map(function (r) {\n    return r.trim();\n  }).join('\\n');\n\n  for (var j = 0; j < pre.length; j++) {\n    var y = pre[j];\n    ret += y;\n\n    if (ESCAPES.indexOf(y) !== -1) {\n      var code = parseFloat(/[0-9][^m]*/.exec(pre.slice(j, j + 4)));\n      escapeCode = code === END_CODE ? null : code;\n    }\n\n    if (escapeCode && ESCAPE_CODES[escapeCode]) {\n      if (pre[j + 1] === '\\n') {\n        ret += wrapAnsi(ESCAPE_CODES[escapeCode]);\n      } else if (y === '\\n') {\n        ret += wrapAnsi(escapeCode);\n      }\n    }\n  }\n\n  return ret;\n} // for each line break, invoke the method separately.\n\n\nmodule.exports = function (str, cols, opts) {\n  return String(str).split('\\n').map(function (substr) {\n    return exec(substr, cols, opts);\n  }).join('\\n');\n};","map":{"version":3,"sources":["/home/marcel/Desktop/CobaProject/GUI backless-js/axsis/node_modules/curlconverter/node_modules/wrap-ansi/index.js"],"names":["stringWidth","require","stripAnsi","ESCAPES","END_CODE","ESCAPE_CODES","wrapAnsi","code","wordLengths","str","split","map","s","wrapWord","rows","word","cols","insideEscape","visible","length","i","x","indexOf","push","pop","exec","opts","options","pre","ret","escapeCode","lengths","words","undefined","rowLength","hard","wordWrap","r","trim","join","j","y","parseFloat","slice","module","exports","String","substr"],"mappings":"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","sourcesContent":["'use strict';\nvar stringWidth = require('string-width');\nvar stripAnsi = require('strip-ansi');\n\nvar ESCAPES = [\n\t'\\u001b',\n\t'\\u009b'\n];\n\nvar END_CODE = 39;\n\nvar ESCAPE_CODES = {\n\t0: 0,\n\t1: 22,\n\t2: 22,\n\t3: 23,\n\t4: 24,\n\t7: 27,\n\t8: 28,\n\t9: 29,\n\t30: 39,\n\t31: 39,\n\t32: 39,\n\t33: 39,\n\t34: 39,\n\t35: 39,\n\t36: 39,\n\t37: 39,\n\t90: 39,\n\t40: 49,\n\t41: 49,\n\t42: 49,\n\t43: 49,\n\t44: 49,\n\t45: 49,\n\t46: 49,\n\t47: 49\n};\n\nfunction wrapAnsi(code) {\n\treturn ESCAPES[0] + '[' + code + 'm';\n}\n\n// calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes.\nfunction wordLengths(str) {\n\treturn str.split(' ').map(function (s) {\n\t\treturn stringWidth(s);\n\t});\n}\n\n// wrap a long word across multiple rows.\n// ansi escape codes do not count towards length.\nfunction wrapWord(rows, word, cols) {\n\tvar insideEscape = false;\n\tvar visible = stripAnsi(rows[rows.length - 1]).length;\n\n\tfor (var i = 0; i < word.length; i++) {\n\t\tvar x = word[i];\n\n\t\trows[rows.length - 1] += x;\n\n\t\tif (ESCAPES.indexOf(x) !== -1) {\n\t\t\tinsideEscape = true;\n\t\t} else if (insideEscape && x === 'm') {\n\t\t\tinsideEscape = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insideEscape) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvisible++;\n\n\t\tif (visible >= cols && i < word.length - 1) {\n\t\t\trows.push('');\n\t\t\tvisible = 0;\n\t\t}\n\t}\n\n\t// it's possible that the last row we copy over is only\n\t// ansi escape characters, handle this edge-case.\n\tif (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n\t\trows[rows.length - 2] += rows.pop();\n\t}\n}\n\n// the wrap-ansi module can be invoked\n// in either 'hard' or 'soft' wrap mode.\n//\n// 'hard' will never allow a string to take up more\n// than cols characters.\n//\n// 'soft' allows long words to expand past the column length.\nfunction exec(str, cols, opts) {\n\tvar options = opts || {};\n\n\tvar pre = '';\n\tvar ret = '';\n\tvar escapeCode;\n\n\tvar lengths = wordLengths(str);\n\tvar words = str.split(' ');\n\tvar rows = [''];\n\n\tfor (var i = 0, word; (word = words[i]) !== undefined; i++) {\n\t\tvar rowLength = stringWidth(rows[rows.length - 1]);\n\n\t\tif (rowLength) {\n\t\t\trows[rows.length - 1] += ' ';\n\t\t\trowLength++;\n\t\t}\n\n\t\t// in 'hard' wrap mode, the length of a line is\n\t\t// never allowed to extend past 'cols'.\n\t\tif (lengths[i] > cols && options.hard) {\n\t\t\tif (rowLength) {\n\t\t\t\trows.push('');\n\t\t\t}\n\t\t\twrapWord(rows, word, cols);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rowLength + lengths[i] > cols && rowLength > 0) {\n\t\t\tif (options.wordWrap === false && rowLength < cols) {\n\t\t\t\twrapWord(rows, word, cols);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trows.push('');\n\t\t}\n\n\t\trows[rows.length - 1] += word;\n\t}\n\n\tpre = rows.map(function (r) {\n\t\treturn r.trim();\n\t}).join('\\n');\n\n\tfor (var j = 0; j < pre.length; j++) {\n\t\tvar y = pre[j];\n\n\t\tret += y;\n\n\t\tif (ESCAPES.indexOf(y) !== -1) {\n\t\t\tvar code = parseFloat(/[0-9][^m]*/.exec(pre.slice(j, j + 4)));\n\t\t\tescapeCode = code === END_CODE ? null : code;\n\t\t}\n\n\t\tif (escapeCode && ESCAPE_CODES[escapeCode]) {\n\t\t\tif (pre[j + 1] === '\\n') {\n\t\t\t\tret += wrapAnsi(ESCAPE_CODES[escapeCode]);\n\t\t\t} else if (y === '\\n') {\n\t\t\t\tret += wrapAnsi(escapeCode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// for each line break, invoke the method separately.\nmodule.exports = function (str, cols, opts) {\n\treturn String(str).split('\\n').map(function (substr) {\n\t\treturn exec(substr, cols, opts);\n\t}).join('\\n');\n};\n"]},"metadata":{},"sourceType":"script"}