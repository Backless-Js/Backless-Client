{"ast":null,"code":"// Generated by CoffeeScript 1.12.4\nvar Inline, ParseException, ParseMore, Parser, Pattern, Utils;\nInline = require('./Inline');\nPattern = require('./Pattern');\nUtils = require('./Utils');\nParseException = require('./Exception/ParseException');\nParseMore = require('./Exception/ParseMore');\n\nParser = function () {\n  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\\\|>]*)\\\\s+)?(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\\\-((?<leadspaces>\\\\s+)(?<value>.+?))?\\\\s*$');\n  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');\n  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\{\\\\[].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\[\\\\{].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\\\d+');\n  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');\n  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\\n*)$');\n  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\\\%YAML[: ][\\\\d\\\\.]+.*\\n', 'm');\n  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\\\#.*?\\n)+', 'm');\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\\\-\\\\-\\\\-.*?\\n', 'm');\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\\\.\\\\.\\\\.\\\\s*$', 'm');\n  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};\n  Parser.prototype.CONTEXT_NONE = 0;\n  Parser.prototype.CONTEXT_SEQUENCE = 1;\n  Parser.prototype.CONTEXT_MAPPING = 2;\n\n  function Parser(offset) {\n    this.offset = offset != null ? offset : 0;\n    this.lines = [];\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.refs = {};\n  }\n\n  Parser.prototype.parse = function (value, exceptionOnInvalidType, objectDecoder) {\n    var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;\n\n    if (exceptionOnInvalidType == null) {\n      exceptionOnInvalidType = false;\n    }\n\n    if (objectDecoder == null) {\n      objectDecoder = null;\n    }\n\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.lines = this.cleanup(value).split(\"\\n\");\n    data = null;\n    context = this.CONTEXT_NONE;\n    allowOverwrite = false;\n\n    while (this.moveToNextLine()) {\n      if (this.isCurrentLineEmpty()) {\n        continue;\n      }\n\n      if (\"\\t\" === this.currentLine[0]) {\n        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n\n      isRef = mergeNode = false;\n\n      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {\n        if (this.CONTEXT_MAPPING === context) {\n          throw new ParseException('You cannot define a sequence item when in a mapping');\n        }\n\n        context = this.CONTEXT_SEQUENCE;\n\n        if (data == null) {\n          data = [];\n        }\n\n        if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n\n        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(null);\n          }\n        } else {\n          if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {\n            c = this.getRealCurrentLineNb();\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            block = values.value;\n            indent = this.getCurrentLineIndentation();\n\n            if (this.isNextLineIndented(false)) {\n              block += \"\\n\" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);\n            }\n\n            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));\n          }\n        }\n      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {\n        if (this.CONTEXT_SEQUENCE === context) {\n          throw new ParseException('You cannot define a mapping item when in a sequence');\n        }\n\n        context = this.CONTEXT_MAPPING;\n\n        if (data == null) {\n          data = {};\n        }\n\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n\n        try {\n          key = Inline.parseScalar(values.key);\n        } catch (error) {\n          e = error;\n          e.parsedLine = this.getRealCurrentLineNb() + 1;\n          e.snippet = this.currentLine;\n          throw e;\n        }\n\n        if ('<<' === key) {\n          mergeNode = true;\n          allowOverwrite = true;\n\n          if (((ref1 = values.value) != null ? ref1.indexOf('*') : void 0) === 0) {\n            refName = values.value.slice(1);\n\n            if (this.refs[refName] == null) {\n              throw new ParseException('Reference \"' + refName + '\" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n\n            refValue = this.refs[refName];\n\n            if (typeof refValue !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n\n            if (refValue instanceof Array) {\n              for (i = j = 0, len = refValue.length; j < len; i = ++j) {\n                value = refValue[i];\n\n                if (data[name = String(i)] == null) {\n                  data[name] = value;\n                }\n              }\n            } else {\n              for (key in refValue) {\n                value = refValue[key];\n\n                if (data[key] == null) {\n                  data[key] = value;\n                }\n              }\n            }\n          } else {\n            if (values.value != null && values.value !== '') {\n              value = values.value;\n            } else {\n              value = this.getNextEmbedBlock();\n            }\n\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            parsed = parser.parse(value, exceptionOnInvalidType);\n\n            if (typeof parsed !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n\n            if (parsed instanceof Array) {\n              for (l = 0, len1 = parsed.length; l < len1; l++) {\n                parsedItem = parsed[l];\n\n                if (typeof parsedItem !== 'object') {\n                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);\n                }\n\n                if (parsedItem instanceof Array) {\n                  for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {\n                    value = parsedItem[i];\n                    k = String(i);\n\n                    if (!data.hasOwnProperty(k)) {\n                      data[k] = value;\n                    }\n                  }\n                } else {\n                  for (key in parsedItem) {\n                    value = parsedItem[key];\n\n                    if (!data.hasOwnProperty(key)) {\n                      data[key] = value;\n                    }\n                  }\n                }\n              }\n            } else {\n              for (key in parsed) {\n                value = parsed[key];\n\n                if (!data.hasOwnProperty(key)) {\n                  data[key] = value;\n                }\n              }\n            }\n          }\n        } else if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n\n        if (mergeNode) {} else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (!this.isNextLineIndented() && !this.isNextLineUnIndentedCollection()) {\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = null;\n            }\n          } else {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);\n\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = val;\n            }\n          }\n        } else {\n          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);\n\n          if (allowOverwrite || data[key] === void 0) {\n            data[key] = val;\n          }\n        }\n      } else {\n        lineCount = this.lines.length;\n\n        if (1 === lineCount || 2 === lineCount && Utils.isEmpty(this.lines[1])) {\n          try {\n            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n\n          if (typeof value === 'object') {\n            if (value instanceof Array) {\n              first = value[0];\n            } else {\n              for (key in value) {\n                first = value[key];\n                break;\n              }\n            }\n\n            if (typeof first === 'string' && first.indexOf('*') === 0) {\n              data = [];\n\n              for (n = 0, len3 = value.length; n < len3; n++) {\n                alias = value[n];\n                data.push(this.refs[alias.slice(1)]);\n              }\n\n              value = data;\n            }\n          }\n\n          return value;\n        } else if ((ref2 = Utils.ltrim(value).charAt(0)) === '[' || ref2 === '{') {\n          try {\n            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n\n        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n\n      if (isRef) {\n        if (data instanceof Array) {\n          this.refs[isRef] = data[data.length - 1];\n        } else {\n          lastKey = null;\n\n          for (key in data) {\n            lastKey = key;\n          }\n\n          this.refs[isRef] = data[lastKey];\n        }\n      }\n    }\n\n    if (Utils.isEmpty(data)) {\n      return null;\n    } else {\n      return data;\n    }\n  };\n\n  Parser.prototype.getRealCurrentLineNb = function () {\n    return this.currentLineNb + this.offset;\n  };\n\n  Parser.prototype.getCurrentLineIndentation = function () {\n    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;\n  };\n\n  Parser.prototype.getNextEmbedBlock = function (indentation, includeUnindentedCollection) {\n    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;\n\n    if (indentation == null) {\n      indentation = null;\n    }\n\n    if (includeUnindentedCollection == null) {\n      includeUnindentedCollection = false;\n    }\n\n    this.moveToNextLine();\n\n    if (indentation == null) {\n      newIndent = this.getCurrentLineIndentation();\n      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);\n\n      if (!this.isCurrentLineEmpty() && 0 === newIndent && !unindentedEmbedBlock) {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    } else {\n      newIndent = indentation;\n    }\n\n    data = [this.currentLine.slice(newIndent)];\n\n    if (!includeUnindentedCollection) {\n      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);\n    }\n\n    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;\n    removeComments = !removeCommentsPattern.test(this.currentLine);\n\n    while (this.moveToNextLine()) {\n      indent = this.getCurrentLineIndentation();\n\n      if (indent === newIndent) {\n        removeComments = !removeCommentsPattern.test(this.currentLine);\n      }\n\n      if (removeComments && this.isCurrentLineComment()) {\n        continue;\n      }\n\n      if (this.isCurrentLineBlank()) {\n        data.push(this.currentLine.slice(newIndent));\n        continue;\n      }\n\n      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {\n        this.moveToPreviousLine();\n        break;\n      }\n\n      if (indent >= newIndent) {\n        data.push(this.currentLine.slice(newIndent));\n      } else if (Utils.ltrim(this.currentLine).charAt(0) === '#') {} else if (0 === indent) {\n        this.moveToPreviousLine();\n        break;\n      } else {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    }\n\n    return data.join(\"\\n\");\n  };\n\n  Parser.prototype.moveToNextLine = function () {\n    if (this.currentLineNb >= this.lines.length - 1) {\n      return false;\n    }\n\n    this.currentLine = this.lines[++this.currentLineNb];\n    return true;\n  };\n\n  Parser.prototype.moveToPreviousLine = function () {\n    this.currentLine = this.lines[--this.currentLineNb];\n  };\n\n  Parser.prototype.parseValue = function (value, exceptionOnInvalidType, objectDecoder) {\n    var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;\n\n    if (0 === value.indexOf('*')) {\n      pos = value.indexOf('#');\n\n      if (pos !== -1) {\n        value = value.substr(1, pos - 2);\n      } else {\n        value = value.slice(1);\n      }\n\n      if (this.refs[value] === void 0) {\n        throw new ParseException('Reference \"' + value + '\" does not exist.', this.currentLine);\n      }\n\n      return this.refs[value];\n    }\n\n    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {\n      modifiers = (ref = matches.modifiers) != null ? ref : '';\n      foldedIndent = Math.abs(parseInt(modifiers));\n\n      if (isNaN(foldedIndent)) {\n        foldedIndent = 0;\n      }\n\n      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);\n\n      if (matches.type != null) {\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        return Inline.parseScalar(matches.type + ' ' + val);\n      } else {\n        return val;\n      }\n    }\n\n    if ((ref1 = value.charAt(0)) === '[' || ref1 === '{' || ref1 === '\"' || ref1 === \"'\") {\n      while (true) {\n        try {\n          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n        } catch (error) {\n          e = error;\n\n          if (e instanceof ParseMore && this.moveToNextLine()) {\n            value += \"\\n\" + Utils.trim(this.currentLine, ' ');\n          } else {\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n      }\n    } else {\n      if (this.isNextLineIndented()) {\n        value += \"\\n\" + this.getNextEmbedBlock();\n      }\n\n      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n    }\n  };\n\n  Parser.prototype.parseFoldedScalar = function (separator, indicator, indentation) {\n    var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;\n\n    if (indicator == null) {\n      indicator = '';\n    }\n\n    if (indentation == null) {\n      indentation = 0;\n    }\n\n    notEOF = this.moveToNextLine();\n\n    if (!notEOF) {\n      return '';\n    }\n\n    isCurrentLineBlank = this.isCurrentLineBlank();\n    text = '';\n\n    while (notEOF && isCurrentLineBlank) {\n      if (notEOF = this.moveToNextLine()) {\n        text += \"\\n\";\n        isCurrentLineBlank = this.isCurrentLineBlank();\n      }\n    }\n\n    if (0 === indentation) {\n      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {\n        indentation = matches[0].length;\n      }\n    }\n\n    if (indentation > 0) {\n      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];\n\n      if (pattern == null) {\n        pattern = new Pattern('^ {' + indentation + '}(.*)$');\n        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;\n      }\n\n      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {\n        if (isCurrentLineBlank) {\n          text += this.currentLine.slice(indentation);\n        } else {\n          text += matches[1];\n        }\n\n        if (notEOF = this.moveToNextLine()) {\n          text += \"\\n\";\n          isCurrentLineBlank = this.isCurrentLineBlank();\n        }\n      }\n    } else if (notEOF) {\n      text += \"\\n\";\n    }\n\n    if (notEOF) {\n      this.moveToPreviousLine();\n    }\n\n    if ('>' === separator) {\n      newText = '';\n      ref = text.split(\"\\n\");\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        line = ref[j];\n\n        if (line.length === 0 || line.charAt(0) === ' ') {\n          newText = Utils.rtrim(newText, ' ') + line + \"\\n\";\n        } else {\n          newText += line + ' ';\n        }\n      }\n\n      text = newText;\n    }\n\n    if ('+' !== indicator) {\n      text = Utils.rtrim(text);\n    }\n\n    if ('' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, \"\\n\");\n    } else if ('-' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, '');\n    }\n\n    return text;\n  };\n\n  Parser.prototype.isNextLineIndented = function (ignoreComments) {\n    var EOF, currentIndentation, ret;\n\n    if (ignoreComments == null) {\n      ignoreComments = true;\n    }\n\n    currentIndentation = this.getCurrentLineIndentation();\n    EOF = !this.moveToNextLine();\n\n    if (ignoreComments) {\n      while (!EOF && this.isCurrentLineEmpty()) {\n        EOF = !this.moveToNextLine();\n      }\n    } else {\n      while (!EOF && this.isCurrentLineBlank()) {\n        EOF = !this.moveToNextLine();\n      }\n    }\n\n    if (EOF) {\n      return false;\n    }\n\n    ret = false;\n\n    if (this.getCurrentLineIndentation() > currentIndentation) {\n      ret = true;\n    }\n\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isCurrentLineEmpty = function () {\n    var trimmedLine;\n    trimmedLine = Utils.trim(this.currentLine, ' ');\n    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.isCurrentLineBlank = function () {\n    return '' === Utils.trim(this.currentLine, ' ');\n  };\n\n  Parser.prototype.isCurrentLineComment = function () {\n    var ltrimmedLine;\n    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');\n    return ltrimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.cleanup = function (value) {\n    var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;\n\n    if (value.indexOf(\"\\r\") !== -1) {\n      value = value.split(\"\\r\\n\").join(\"\\n\").split(\"\\r\").join(\"\\n\");\n    }\n\n    count = 0;\n    ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = ref[0], count = ref[1];\n    this.offset += count;\n    ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = ref1[0], count = ref1[1];\n\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n    }\n\n    ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = ref2[0], count = ref2[1];\n\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');\n    }\n\n    lines = value.split(\"\\n\");\n    smallestIndent = -1;\n\n    for (j = 0, len = lines.length; j < len; j++) {\n      line = lines[j];\n\n      if (Utils.trim(line, ' ').length === 0) {\n        continue;\n      }\n\n      indent = line.length - Utils.ltrim(line).length;\n\n      if (smallestIndent === -1 || indent < smallestIndent) {\n        smallestIndent = indent;\n      }\n    }\n\n    if (smallestIndent > 0) {\n      for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {\n        line = lines[i];\n        lines[i] = line.slice(smallestIndent);\n      }\n\n      value = lines.join(\"\\n\");\n    }\n\n    return value;\n  };\n\n  Parser.prototype.isNextLineUnIndentedCollection = function (currentIndentation) {\n    var notEOF, ret;\n\n    if (currentIndentation == null) {\n      currentIndentation = null;\n    }\n\n    if (currentIndentation == null) {\n      currentIndentation = this.getCurrentLineIndentation();\n    }\n\n    notEOF = this.moveToNextLine();\n\n    while (notEOF && this.isCurrentLineEmpty()) {\n      notEOF = this.moveToNextLine();\n    }\n\n    if (false === notEOF) {\n      return false;\n    }\n\n    ret = false;\n\n    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {\n      ret = true;\n    }\n\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isStringUnIndentedCollectionItem = function () {\n    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';\n  };\n\n  return Parser;\n}();\n\nmodule.exports = Parser;","map":{"version":3,"sources":["/home/marcel/Desktop/CobaProject/GUI backless-js/axsis/node_modules/yamljs/lib/Parser.js"],"names":["Inline","ParseException","ParseMore","Parser","Pattern","Utils","require","prototype","PATTERN_FOLDED_SCALAR_ALL","PATTERN_FOLDED_SCALAR_END","PATTERN_SEQUENCE_ITEM","PATTERN_ANCHOR_VALUE","PATTERN_COMPACT_NOTATION","REGEX_QUOTED_STRING","PATTERN_MAPPING_ITEM","PATTERN_DECIMAL","PATTERN_INDENT_SPACES","PATTERN_TRAILING_LINES","PATTERN_YAML_HEADER","PATTERN_LEADING_COMMENTS","PATTERN_DOCUMENT_MARKER_START","PATTERN_DOCUMENT_MARKER_END","PATTERN_FOLDED_SCALAR_BY_INDENTATION","CONTEXT_NONE","CONTEXT_SEQUENCE","CONTEXT_MAPPING","offset","lines","currentLineNb","currentLine","refs","parse","value","exceptionOnInvalidType","objectDecoder","alias","allowOverwrite","block","c","context","data","e","first","i","indent","isRef","j","k","key","l","lastKey","len","len1","len2","len3","lineCount","m","matches","mergeNode","n","name","parsed","parsedItem","parser","ref","ref1","ref2","refName","refValue","val","values","cleanup","split","moveToNextLine","isCurrentLineEmpty","getRealCurrentLineNb","exec","trim","ltrim","indexOf","length","isNextLineUnIndentedCollection","push","getNextEmbedBlock","leadspaces","getCurrentLineIndentation","isNextLineIndented","parseValue","configure","parseScalar","error","parsedLine","snippet","slice","Array","String","hasOwnProperty","isEmpty","charAt","indentation","includeUnindentedCollection","isItUnindentedCollection","newIndent","removeComments","removeCommentsPattern","unindentedEmbedBlock","isStringUnIndentedCollectionItem","test","isCurrentLineComment","isCurrentLineBlank","moveToPreviousLine","join","foldedIndent","modifiers","pos","substr","Math","abs","parseInt","isNaN","parseFoldedScalar","separator","replace","type","indicator","line","newText","notEOF","pattern","text","rtrim","ignoreComments","EOF","currentIndentation","ret","trimmedLine","ltrimmedLine","count","smallestIndent","trimmedValue","replaceAll","subStrCount","module","exports"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 1.12.4\nvar Inline, ParseException, ParseMore, Parser, Pattern, Utils;\n\nInline = require('./Inline');\n\nPattern = require('./Pattern');\n\nUtils = require('./Utils');\n\nParseException = require('./Exception/ParseException');\n\nParseMore = require('./Exception/ParseMore');\n\nParser = (function() {\n  Parser.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern('^(?:(?<type>![^\\\\|>]*)\\\\s+)?(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n\n  Parser.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern('(?<separator>\\\\||>)(?<modifiers>\\\\+|\\\\-|\\\\d+|\\\\+\\\\d+|\\\\-\\\\d+|\\\\d+\\\\+|\\\\d+\\\\-)?(?<comments> +#.*)?$');\n\n  Parser.prototype.PATTERN_SEQUENCE_ITEM = new Pattern('^\\\\-((?<leadspaces>\\\\s+)(?<value>.+?))?\\\\s*$');\n\n  Parser.prototype.PATTERN_ANCHOR_VALUE = new Pattern('^&(?<ref>[^ ]+) *(?<value>.*)');\n\n  Parser.prototype.PATTERN_COMPACT_NOTATION = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\{\\\\[].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n\n  Parser.prototype.PATTERN_MAPPING_ITEM = new Pattern('^(?<key>' + Inline.REGEX_QUOTED_STRING + '|[^ \\'\"\\\\[\\\\{].*?) *\\\\:(\\\\s+(?<value>.+?))?\\\\s*$');\n\n  Parser.prototype.PATTERN_DECIMAL = new Pattern('\\\\d+');\n\n  Parser.prototype.PATTERN_INDENT_SPACES = new Pattern('^ +');\n\n  Parser.prototype.PATTERN_TRAILING_LINES = new Pattern('(\\n*)$');\n\n  Parser.prototype.PATTERN_YAML_HEADER = new Pattern('^\\\\%YAML[: ][\\\\d\\\\.]+.*\\n', 'm');\n\n  Parser.prototype.PATTERN_LEADING_COMMENTS = new Pattern('^(\\\\#.*?\\n)+', 'm');\n\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern('^\\\\-\\\\-\\\\-.*?\\n', 'm');\n\n  Parser.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern('^\\\\.\\\\.\\\\.\\\\s*$', 'm');\n\n  Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};\n\n  Parser.prototype.CONTEXT_NONE = 0;\n\n  Parser.prototype.CONTEXT_SEQUENCE = 1;\n\n  Parser.prototype.CONTEXT_MAPPING = 2;\n\n  function Parser(offset) {\n    this.offset = offset != null ? offset : 0;\n    this.lines = [];\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.refs = {};\n  }\n\n  Parser.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {\n    var alias, allowOverwrite, block, c, context, data, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;\n    if (exceptionOnInvalidType == null) {\n      exceptionOnInvalidType = false;\n    }\n    if (objectDecoder == null) {\n      objectDecoder = null;\n    }\n    this.currentLineNb = -1;\n    this.currentLine = '';\n    this.lines = this.cleanup(value).split(\"\\n\");\n    data = null;\n    context = this.CONTEXT_NONE;\n    allowOverwrite = false;\n    while (this.moveToNextLine()) {\n      if (this.isCurrentLineEmpty()) {\n        continue;\n      }\n      if (\"\\t\" === this.currentLine[0]) {\n        throw new ParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n      isRef = mergeNode = false;\n      if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {\n        if (this.CONTEXT_MAPPING === context) {\n          throw new ParseException('You cannot define a sequence item when in a mapping');\n        }\n        context = this.CONTEXT_SEQUENCE;\n        if (data == null) {\n          data = [];\n        }\n        if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n        if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            data.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(null);\n          }\n        } else {\n          if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {\n            c = this.getRealCurrentLineNb();\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            block = values.value;\n            indent = this.getCurrentLineIndentation();\n            if (this.isNextLineIndented(false)) {\n              block += \"\\n\" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);\n            }\n            data.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));\n          } else {\n            data.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));\n          }\n        }\n      } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(' #') === -1) {\n        if (this.CONTEXT_SEQUENCE === context) {\n          throw new ParseException('You cannot define a mapping item when in a sequence');\n        }\n        context = this.CONTEXT_MAPPING;\n        if (data == null) {\n          data = {};\n        }\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        try {\n          key = Inline.parseScalar(values.key);\n        } catch (error) {\n          e = error;\n          e.parsedLine = this.getRealCurrentLineNb() + 1;\n          e.snippet = this.currentLine;\n          throw e;\n        }\n        if ('<<' === key) {\n          mergeNode = true;\n          allowOverwrite = true;\n          if (((ref1 = values.value) != null ? ref1.indexOf('*') : void 0) === 0) {\n            refName = values.value.slice(1);\n            if (this.refs[refName] == null) {\n              throw new ParseException('Reference \"' + refName + '\" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            refValue = this.refs[refName];\n            if (typeof refValue !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            if (refValue instanceof Array) {\n              for (i = j = 0, len = refValue.length; j < len; i = ++j) {\n                value = refValue[i];\n                if (data[name = String(i)] == null) {\n                  data[name] = value;\n                }\n              }\n            } else {\n              for (key in refValue) {\n                value = refValue[key];\n                if (data[key] == null) {\n                  data[key] = value;\n                }\n              }\n            }\n          } else {\n            if ((values.value != null) && values.value !== '') {\n              value = values.value;\n            } else {\n              value = this.getNextEmbedBlock();\n            }\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            parsed = parser.parse(value, exceptionOnInvalidType);\n            if (typeof parsed !== 'object') {\n              throw new ParseException('YAML merge keys used with a scalar value instead of an object.', this.getRealCurrentLineNb() + 1, this.currentLine);\n            }\n            if (parsed instanceof Array) {\n              for (l = 0, len1 = parsed.length; l < len1; l++) {\n                parsedItem = parsed[l];\n                if (typeof parsedItem !== 'object') {\n                  throw new ParseException('Merge items must be objects.', this.getRealCurrentLineNb() + 1, parsedItem);\n                }\n                if (parsedItem instanceof Array) {\n                  for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {\n                    value = parsedItem[i];\n                    k = String(i);\n                    if (!data.hasOwnProperty(k)) {\n                      data[k] = value;\n                    }\n                  }\n                } else {\n                  for (key in parsedItem) {\n                    value = parsedItem[key];\n                    if (!data.hasOwnProperty(key)) {\n                      data[key] = value;\n                    }\n                  }\n                }\n              }\n            } else {\n              for (key in parsed) {\n                value = parsed[key];\n                if (!data.hasOwnProperty(key)) {\n                  data[key] = value;\n                }\n              }\n            }\n          }\n        } else if ((values.value != null) && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {\n          isRef = matches.ref;\n          values.value = matches.value;\n        }\n        if (mergeNode) {\n\n        } else if (!(values.value != null) || '' === Utils.trim(values.value, ' ') || Utils.ltrim(values.value, ' ').indexOf('#') === 0) {\n          if (!(this.isNextLineIndented()) && !(this.isNextLineUnIndentedCollection())) {\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = null;\n            }\n          } else {\n            c = this.getRealCurrentLineNb() + 1;\n            parser = new Parser(c);\n            parser.refs = this.refs;\n            val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);\n            if (allowOverwrite || data[key] === void 0) {\n              data[key] = val;\n            }\n          }\n        } else {\n          val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);\n          if (allowOverwrite || data[key] === void 0) {\n            data[key] = val;\n          }\n        }\n      } else {\n        lineCount = this.lines.length;\n        if (1 === lineCount || (2 === lineCount && Utils.isEmpty(this.lines[1]))) {\n          try {\n            value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n          if (typeof value === 'object') {\n            if (value instanceof Array) {\n              first = value[0];\n            } else {\n              for (key in value) {\n                first = value[key];\n                break;\n              }\n            }\n            if (typeof first === 'string' && first.indexOf('*') === 0) {\n              data = [];\n              for (n = 0, len3 = value.length; n < len3; n++) {\n                alias = value[n];\n                data.push(this.refs[alias.slice(1)]);\n              }\n              value = data;\n            }\n          }\n          return value;\n        } else if ((ref2 = Utils.ltrim(value).charAt(0)) === '[' || ref2 === '{') {\n          try {\n            return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n          } catch (error) {\n            e = error;\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n        throw new ParseException('Unable to parse.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n      if (isRef) {\n        if (data instanceof Array) {\n          this.refs[isRef] = data[data.length - 1];\n        } else {\n          lastKey = null;\n          for (key in data) {\n            lastKey = key;\n          }\n          this.refs[isRef] = data[lastKey];\n        }\n      }\n    }\n    if (Utils.isEmpty(data)) {\n      return null;\n    } else {\n      return data;\n    }\n  };\n\n  Parser.prototype.getRealCurrentLineNb = function() {\n    return this.currentLineNb + this.offset;\n  };\n\n  Parser.prototype.getCurrentLineIndentation = function() {\n    return this.currentLine.length - Utils.ltrim(this.currentLine, ' ').length;\n  };\n\n  Parser.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {\n    var data, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;\n    if (indentation == null) {\n      indentation = null;\n    }\n    if (includeUnindentedCollection == null) {\n      includeUnindentedCollection = false;\n    }\n    this.moveToNextLine();\n    if (indentation == null) {\n      newIndent = this.getCurrentLineIndentation();\n      unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);\n      if (!(this.isCurrentLineEmpty()) && 0 === newIndent && !unindentedEmbedBlock) {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    } else {\n      newIndent = indentation;\n    }\n    data = [this.currentLine.slice(newIndent)];\n    if (!includeUnindentedCollection) {\n      isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);\n    }\n    removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;\n    removeComments = !removeCommentsPattern.test(this.currentLine);\n    while (this.moveToNextLine()) {\n      indent = this.getCurrentLineIndentation();\n      if (indent === newIndent) {\n        removeComments = !removeCommentsPattern.test(this.currentLine);\n      }\n      if (removeComments && this.isCurrentLineComment()) {\n        continue;\n      }\n      if (this.isCurrentLineBlank()) {\n        data.push(this.currentLine.slice(newIndent));\n        continue;\n      }\n      if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {\n        this.moveToPreviousLine();\n        break;\n      }\n      if (indent >= newIndent) {\n        data.push(this.currentLine.slice(newIndent));\n      } else if (Utils.ltrim(this.currentLine).charAt(0) === '#') {\n\n      } else if (0 === indent) {\n        this.moveToPreviousLine();\n        break;\n      } else {\n        throw new ParseException('Indentation problem.', this.getRealCurrentLineNb() + 1, this.currentLine);\n      }\n    }\n    return data.join(\"\\n\");\n  };\n\n  Parser.prototype.moveToNextLine = function() {\n    if (this.currentLineNb >= this.lines.length - 1) {\n      return false;\n    }\n    this.currentLine = this.lines[++this.currentLineNb];\n    return true;\n  };\n\n  Parser.prototype.moveToPreviousLine = function() {\n    this.currentLine = this.lines[--this.currentLineNb];\n  };\n\n  Parser.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {\n    var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;\n    if (0 === value.indexOf('*')) {\n      pos = value.indexOf('#');\n      if (pos !== -1) {\n        value = value.substr(1, pos - 2);\n      } else {\n        value = value.slice(1);\n      }\n      if (this.refs[value] === void 0) {\n        throw new ParseException('Reference \"' + value + '\" does not exist.', this.currentLine);\n      }\n      return this.refs[value];\n    }\n    if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {\n      modifiers = (ref = matches.modifiers) != null ? ref : '';\n      foldedIndent = Math.abs(parseInt(modifiers));\n      if (isNaN(foldedIndent)) {\n        foldedIndent = 0;\n      }\n      val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ''), foldedIndent);\n      if (matches.type != null) {\n        Inline.configure(exceptionOnInvalidType, objectDecoder);\n        return Inline.parseScalar(matches.type + ' ' + val);\n      } else {\n        return val;\n      }\n    }\n    if ((ref1 = value.charAt(0)) === '[' || ref1 === '{' || ref1 === '\"' || ref1 === \"'\") {\n      while (true) {\n        try {\n          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n        } catch (error) {\n          e = error;\n          if (e instanceof ParseMore && this.moveToNextLine()) {\n            value += \"\\n\" + Utils.trim(this.currentLine, ' ');\n          } else {\n            e.parsedLine = this.getRealCurrentLineNb() + 1;\n            e.snippet = this.currentLine;\n            throw e;\n          }\n        }\n      }\n    } else {\n      if (this.isNextLineIndented()) {\n        value += \"\\n\" + this.getNextEmbedBlock();\n      }\n      return Inline.parse(value, exceptionOnInvalidType, objectDecoder);\n    }\n  };\n\n  Parser.prototype.parseFoldedScalar = function(separator, indicator, indentation) {\n    var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;\n    if (indicator == null) {\n      indicator = '';\n    }\n    if (indentation == null) {\n      indentation = 0;\n    }\n    notEOF = this.moveToNextLine();\n    if (!notEOF) {\n      return '';\n    }\n    isCurrentLineBlank = this.isCurrentLineBlank();\n    text = '';\n    while (notEOF && isCurrentLineBlank) {\n      if (notEOF = this.moveToNextLine()) {\n        text += \"\\n\";\n        isCurrentLineBlank = this.isCurrentLineBlank();\n      }\n    }\n    if (0 === indentation) {\n      if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {\n        indentation = matches[0].length;\n      }\n    }\n    if (indentation > 0) {\n      pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];\n      if (pattern == null) {\n        pattern = new Pattern('^ {' + indentation + '}(.*)$');\n        Parser.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;\n      }\n      while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {\n        if (isCurrentLineBlank) {\n          text += this.currentLine.slice(indentation);\n        } else {\n          text += matches[1];\n        }\n        if (notEOF = this.moveToNextLine()) {\n          text += \"\\n\";\n          isCurrentLineBlank = this.isCurrentLineBlank();\n        }\n      }\n    } else if (notEOF) {\n      text += \"\\n\";\n    }\n    if (notEOF) {\n      this.moveToPreviousLine();\n    }\n    if ('>' === separator) {\n      newText = '';\n      ref = text.split(\"\\n\");\n      for (j = 0, len = ref.length; j < len; j++) {\n        line = ref[j];\n        if (line.length === 0 || line.charAt(0) === ' ') {\n          newText = Utils.rtrim(newText, ' ') + line + \"\\n\";\n        } else {\n          newText += line + ' ';\n        }\n      }\n      text = newText;\n    }\n    if ('+' !== indicator) {\n      text = Utils.rtrim(text);\n    }\n    if ('' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, \"\\n\");\n    } else if ('-' === indicator) {\n      text = this.PATTERN_TRAILING_LINES.replace(text, '');\n    }\n    return text;\n  };\n\n  Parser.prototype.isNextLineIndented = function(ignoreComments) {\n    var EOF, currentIndentation, ret;\n    if (ignoreComments == null) {\n      ignoreComments = true;\n    }\n    currentIndentation = this.getCurrentLineIndentation();\n    EOF = !this.moveToNextLine();\n    if (ignoreComments) {\n      while (!EOF && this.isCurrentLineEmpty()) {\n        EOF = !this.moveToNextLine();\n      }\n    } else {\n      while (!EOF && this.isCurrentLineBlank()) {\n        EOF = !this.moveToNextLine();\n      }\n    }\n    if (EOF) {\n      return false;\n    }\n    ret = false;\n    if (this.getCurrentLineIndentation() > currentIndentation) {\n      ret = true;\n    }\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isCurrentLineEmpty = function() {\n    var trimmedLine;\n    trimmedLine = Utils.trim(this.currentLine, ' ');\n    return trimmedLine.length === 0 || trimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.isCurrentLineBlank = function() {\n    return '' === Utils.trim(this.currentLine, ' ');\n  };\n\n  Parser.prototype.isCurrentLineComment = function() {\n    var ltrimmedLine;\n    ltrimmedLine = Utils.ltrim(this.currentLine, ' ');\n    return ltrimmedLine.charAt(0) === '#';\n  };\n\n  Parser.prototype.cleanup = function(value) {\n    var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;\n    if (value.indexOf(\"\\r\") !== -1) {\n      value = value.split(\"\\r\\n\").join(\"\\n\").split(\"\\r\").join(\"\\n\");\n    }\n    count = 0;\n    ref = this.PATTERN_YAML_HEADER.replaceAll(value, ''), value = ref[0], count = ref[1];\n    this.offset += count;\n    ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, '', 1), trimmedValue = ref1[0], count = ref1[1];\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n    }\n    ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, '', 1), trimmedValue = ref2[0], count = ref2[1];\n    if (count === 1) {\n      this.offset += Utils.subStrCount(value, \"\\n\") - Utils.subStrCount(trimmedValue, \"\\n\");\n      value = trimmedValue;\n      value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, '');\n    }\n    lines = value.split(\"\\n\");\n    smallestIndent = -1;\n    for (j = 0, len = lines.length; j < len; j++) {\n      line = lines[j];\n      if (Utils.trim(line, ' ').length === 0) {\n        continue;\n      }\n      indent = line.length - Utils.ltrim(line).length;\n      if (smallestIndent === -1 || indent < smallestIndent) {\n        smallestIndent = indent;\n      }\n    }\n    if (smallestIndent > 0) {\n      for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {\n        line = lines[i];\n        lines[i] = line.slice(smallestIndent);\n      }\n      value = lines.join(\"\\n\");\n    }\n    return value;\n  };\n\n  Parser.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {\n    var notEOF, ret;\n    if (currentIndentation == null) {\n      currentIndentation = null;\n    }\n    if (currentIndentation == null) {\n      currentIndentation = this.getCurrentLineIndentation();\n    }\n    notEOF = this.moveToNextLine();\n    while (notEOF && this.isCurrentLineEmpty()) {\n      notEOF = this.moveToNextLine();\n    }\n    if (false === notEOF) {\n      return false;\n    }\n    ret = false;\n    if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {\n      ret = true;\n    }\n    this.moveToPreviousLine();\n    return ret;\n  };\n\n  Parser.prototype.isStringUnIndentedCollectionItem = function() {\n    return this.currentLine === '-' || this.currentLine.slice(0, 2) === '- ';\n  };\n\n  return Parser;\n\n})();\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}