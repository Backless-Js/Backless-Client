{"ast":null,"code":"const jsesc = require('jsesc');\n\nconst repr = value => {\n  // In context of url parameters, don't accept nulls and such.\n  if (!value) {\n    return \"''\";\n  }\n\n  return \"'\" + jsesc(value, {\n    quotes: 'single'\n  }).replace(/\\\\'/g, \"''\") + \"'\";\n};\n\nconst setVariableValue = (outputVariable, value, termination) => {\n  let result = '';\n\n  if (outputVariable) {\n    result += outputVariable + ' = ';\n  }\n\n  result += value;\n  result += typeof termination === 'undefined' || termination === null ? ';' : termination;\n  return result;\n};\n\nconst callFunction = (outputVariable, functionName, params, termination) => {\n  let functionCall = functionName + '(';\n\n  if (Array.isArray(params)) {\n    const singleLine = params.map(x => Array.isArray(x) ? x.join(', ') : x).join(', ');\n    const indentLevel = 1;\n    const indent = ' '.repeat(4 * indentLevel);\n    const skipToNextLine = '...\\n' + indent;\n    let multiLine = skipToNextLine;\n    multiLine += params.map(x => Array.isArray(x) ? x.join(', ') : x).join(',' + skipToNextLine);\n    multiLine += '...\\n'; // Split the params in multiple lines - if one line is not enough\n\n    const combinedSingleLineLength = [outputVariable, functionName, singleLine].map(x => x ? x.length : 0).reduce((x, y) => x + y) + (outputVariable ? 3 : 0) + 2 + (termination ? termination.length : 1);\n    functionCall += combinedSingleLineLength < 120 ? singleLine : multiLine;\n  } else {\n    functionCall += params;\n  }\n\n  functionCall += ')';\n  return setVariableValue(outputVariable, functionCall, termination);\n};\n\nconst addCellArray = (mapping, keysNotToQuote, keyValSeparator, indentLevel, pairs) => {\n  const indentUnit = ' '.repeat(4);\n  const indent = indentUnit.repeat(indentLevel);\n  const indentPrevLevel = indentUnit.repeat(indentLevel - 1);\n  const entries = Object.entries(mapping);\n  if (entries.length === 0) return '';\n  let response = pairs ? '' : '{';\n\n  if (entries.length === 1) {\n    let [key, value] = entries.pop();\n    if (keysNotToQuote && !keysNotToQuote.includes(key)) value = `${repr(value)}`;\n    response += `${repr(key)}${keyValSeparator} ${value}`;\n  } else {\n    if (pairs) response += '...';\n    let counter = entries.length;\n\n    for (let [key, value] of entries) {\n      --counter;\n\n      if (keysNotToQuote && !keysNotToQuote.includes(key)) {\n        if (typeof value === 'object') {\n          value = `[${value.map(repr).join()}]`;\n        } else {\n          value = `${repr(value)}`;\n        }\n      }\n\n      response += `\\n${indent}${repr(key)}${keyValSeparator} ${value}`;\n\n      if (pairs) {\n        if (counter !== 0) response += ',';\n        response += '...';\n      }\n    }\n\n    response += `\\n${indentPrevLevel}`;\n  }\n\n  response += pairs ? '' : '}';\n  return response;\n};\n\nconst structify = (obj, indentLevel) => {\n  let response = '';\n  indentLevel = !indentLevel ? 1 : ++indentLevel;\n  const indent = ' '.repeat(4 * indentLevel);\n  const prevIndent = ' '.repeat(4 * (indentLevel - 1));\n\n  if (obj instanceof Array) {\n    const list = [];\n    let listContainsNumbers = true;\n\n    for (const k in obj) {\n      if (listContainsNumbers && typeof obj[k] !== 'number') {\n        listContainsNumbers = false;\n      }\n\n      const value = structify(obj[k], indentLevel);\n      list.push(`${value}`);\n    }\n\n    if (listContainsNumbers) {\n      const listString = list.join(' ');\n      response += `[${listString}]`;\n    } else {\n      list.unshift('{{');\n      const listString = list.join(`\\n${indent}`);\n      response += `${listString}\\n${prevIndent}}}`;\n    }\n  } else if (obj instanceof Object) {\n    response += 'struct(...';\n    let first = true;\n\n    for (const k in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, k)) {\n        if (!k[0].match(/[a-z]/i)) {\n          throw Error('MATLAB structs do not support keys starting with non-alphabet symbols');\n        } // recursive call to scan property\n\n\n        if (first) {\n          first = false;\n        } else {\n          response += ',...';\n        }\n\n        response += `\\n${indent}`;\n        response += `'${k}', `;\n        response += structify(obj[k], indentLevel);\n      }\n    }\n\n    response += '...';\n    response += `\\n${prevIndent})`;\n  } else if (typeof obj === 'number') {\n    // not an Object so obj[k] here is a value\n    response += `${obj}`;\n  } else {\n    response += `${repr(obj)}`;\n  }\n\n  return response;\n};\n\nconst containsBody = request => {\n  return request.data || request.multipartUploads;\n};\n\nconst prepareQueryString = request => {\n  let response = null;\n\n  if (request.query) {\n    const params = addCellArray(request.query, [], '', 1);\n    response = setVariableValue('params', params);\n  }\n\n  return response;\n};\n\nconst prepareCookies = request => {\n  let response = null;\n\n  if (request.cookies) {\n    const cookies = addCellArray(request.cookies, [], '', 1);\n    response = setVariableValue('cookies', cookies);\n  }\n\n  return response;\n};\n\nconst cookieString = 'char(join(join(cookies, \\'=\\'), \\'; \\'))';\nconst paramsString = 'char(join(join(params, \\'=\\'), \\'&\\'))';\nmodule.exports = {\n  repr: repr,\n  setVariableValue: setVariableValue,\n  callFunction: callFunction,\n  addCellArray: addCellArray,\n  structify: structify,\n  containsBody: containsBody,\n  prepareQueryString: prepareQueryString,\n  prepareCookies: prepareCookies,\n  cookieString: cookieString,\n  paramsString: paramsString\n};","map":{"version":3,"sources":["/home/marcel/Desktop/CobaProject/GUI backless-js/axsis/node_modules/curlconverter/generators/matlab/common.js"],"names":["jsesc","require","repr","value","quotes","replace","setVariableValue","outputVariable","termination","result","callFunction","functionName","params","functionCall","Array","isArray","singleLine","map","x","join","indentLevel","indent","repeat","skipToNextLine","multiLine","combinedSingleLineLength","length","reduce","y","addCellArray","mapping","keysNotToQuote","keyValSeparator","pairs","indentUnit","indentPrevLevel","entries","Object","response","key","pop","includes","counter","structify","obj","prevIndent","list","listContainsNumbers","k","push","listString","unshift","first","prototype","hasOwnProperty","call","match","Error","containsBody","request","data","multipartUploads","prepareQueryString","query","prepareCookies","cookies","cookieString","paramsString","module","exports"],"mappings":"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","sourcesContent":["const jsesc = require('jsesc')\n\nconst repr = (value) => {\n  // In context of url parameters, don't accept nulls and such.\n  if (!value) {\n    return \"''\"\n  }\n\n  return \"'\" + jsesc(value, { quotes: 'single' }).replace(/\\\\'/g, \"''\") + \"'\"\n}\n\nconst setVariableValue = (outputVariable, value, termination) => {\n  let result = ''\n\n  if (outputVariable) {\n    result += outputVariable + ' = '\n  }\n\n  result += value\n  result += typeof termination === 'undefined' || termination === null ? ';' : termination\n  return result\n}\n\nconst callFunction = (outputVariable, functionName, params, termination) => {\n  let functionCall = functionName + '('\n  if (Array.isArray(params)) {\n    const singleLine = params.map(x => Array.isArray(x) ? x.join(', ') : x).join(', ')\n    const indentLevel = 1\n    const indent = ' '.repeat(4 * indentLevel)\n    const skipToNextLine = '...\\n' + indent\n    let multiLine = skipToNextLine\n    multiLine += params.map(x => Array.isArray(x) ? x.join(', ') : x)\n      .join(',' + skipToNextLine)\n    multiLine += '...\\n'\n\n    // Split the params in multiple lines - if one line is not enough\n    const combinedSingleLineLength = [outputVariable, functionName, singleLine]\n        .map(x => x ? x.length : 0).reduce((x, y) => x + y) +\n      (outputVariable ? 3 : 0) + 2 + (termination ? termination.length : 1)\n    functionCall += combinedSingleLineLength < 120 ? singleLine : multiLine\n  } else {\n    functionCall += params\n  }\n  functionCall += ')'\n  return setVariableValue(outputVariable, functionCall, termination)\n}\n\nconst addCellArray = (mapping, keysNotToQuote, keyValSeparator, indentLevel, pairs) => {\n  const indentUnit = ' '.repeat(4)\n  const indent = indentUnit.repeat(indentLevel)\n  const indentPrevLevel = indentUnit.repeat(indentLevel - 1)\n\n  const entries = Object.entries(mapping)\n  if (entries.length === 0) return ''\n\n  let response = pairs ? '' : '{'\n  if (entries.length === 1) {\n    let [key, value] = entries.pop()\n    if (keysNotToQuote && !keysNotToQuote.includes(key)) value = `${repr(value)}`\n    response += `${repr(key)}${keyValSeparator} ${value}`\n  } else {\n    if (pairs) response += '...'\n    let counter = entries.length\n    for (let [key, value] of entries) {\n      --counter\n      if (keysNotToQuote && !keysNotToQuote.includes(key)) {\n        if (typeof value === 'object') {\n          value = `[${value.map(repr).join()}]`\n        } else {\n          value = `${repr(value)}`\n        }\n      }\n      response += `\\n${indent}${repr(key)}${keyValSeparator} ${value}`\n      if (pairs) {\n        if (counter !== 0) response += ','\n        response += '...'\n      }\n    }\n    response += `\\n${indentPrevLevel}`\n  }\n  response += pairs ? '' : '}'\n  return response\n}\n\nconst structify = (obj, indentLevel) => {\n  let response = ''\n  indentLevel = !indentLevel ? 1 : ++indentLevel\n  const indent = ' '.repeat(4 * indentLevel)\n  const prevIndent = ' '.repeat(4 * (indentLevel - 1))\n\n  if (obj instanceof Array) {\n    const list = []\n    let listContainsNumbers = true\n    for (const k in obj) {\n      if (listContainsNumbers && typeof obj[k] !== 'number') {\n        listContainsNumbers = false\n      }\n      const value = structify(obj[k], indentLevel)\n      list.push(`${value}`)\n    }\n    if (listContainsNumbers) {\n      const listString = list.join(' ')\n      response += `[${listString}]`\n    } else {\n      list.unshift('{{')\n      const listString = list.join(`\\n${indent}`)\n      response += `${listString}\\n${prevIndent}}}`\n    }\n  } else if (obj instanceof Object) {\n    response += 'struct(...'\n    let first = true\n    for (const k in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, k)) {\n        if (!k[0].match(/[a-z]/i)) {\n          throw Error('MATLAB structs do not support keys starting with non-alphabet symbols')\n        }\n        // recursive call to scan property\n        if (first) { first = false } else {\n          response += ',...'\n        }\n        response += `\\n${indent}`\n        response += `'${k}', `\n        response += structify(obj[k], indentLevel)\n      }\n    }\n    response += '...'\n    response += `\\n${prevIndent})`\n  } else if (typeof obj === 'number') {\n    // not an Object so obj[k] here is a value\n    response += `${obj}`\n  } else {\n    response += `${repr(obj)}`\n  }\n\n  return response\n}\n\nconst containsBody = (request) => {\n  return request.data || request.multipartUploads\n}\n\nconst prepareQueryString = (request) => {\n  let response = null\n  if (request.query) {\n    const params = addCellArray(request.query, [], '', 1)\n    response = setVariableValue('params', params)\n  }\n  return response\n}\n\nconst prepareCookies = (request) => {\n  let response = null\n  if (request.cookies) {\n    const cookies = addCellArray(request.cookies, [], '', 1)\n    response = setVariableValue('cookies', cookies)\n  }\n  return response\n}\n\nconst cookieString = 'char(join(join(cookies, \\'=\\'), \\'; \\'))'\nconst paramsString = 'char(join(join(params, \\'=\\'), \\'&\\'))'\n\nmodule.exports = {\n  repr: repr,\n  setVariableValue: setVariableValue,\n  callFunction: callFunction,\n  addCellArray: addCellArray,\n  structify: structify,\n  containsBody: containsBody,\n  prepareQueryString: prepareQueryString,\n  prepareCookies: prepareCookies,\n  cookieString: cookieString,\n  paramsString: paramsString\n}\n"]},"metadata":{},"sourceType":"script"}