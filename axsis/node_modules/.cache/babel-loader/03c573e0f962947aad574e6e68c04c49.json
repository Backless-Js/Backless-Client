{"ast":null,"code":"const {\n  repr,\n  setVariableValue,\n  callFunction,\n  addCellArray,\n  structify,\n  containsBody,\n  prepareQueryString,\n  prepareCookies,\n  cookieString,\n  paramsString\n} = require('./common');\n\nconst isSupportedByWebServices = request => {\n  if (!new Set(['get', 'post', 'put', 'delete', 'patch']).has(request.method)) {\n    return false;\n  }\n\n  return !request.multipartUploads && !request.insecure;\n};\n\nconst parseWebOptions = request => {\n  const options = {}; // MATLAB uses GET in `webread` and POST in `webwrite` by default\n  // thus, it is necessary to set the method for other requests\n\n  if (request.method !== 'get' && request.method !== 'post') {\n    options.RequestMethod = request.method;\n  }\n\n  const headers = {};\n\n  if (request.auth) {\n    const [username, password] = request.auth.split(':');\n\n    if (username !== '') {\n      options.Username = username;\n      options.Password = password;\n    } else {\n      headers.Authorization = `['Basic ' matlab.net.base64encode(${repr(username + ':' + password)})]`;\n    }\n  }\n\n  if (request.headers) {\n    for (const [key, value] of Object.entries(request.headers)) {\n      switch (key) {\n        case 'User-Agent':\n          options.UserAgent = value;\n          break;\n\n        case 'Content-Type':\n          options.MediaType = value;\n          break;\n\n        case 'Cookie':\n          headers.Cookie = value;\n          break;\n\n        case 'Accept':\n          switch (value) {\n            case 'application/json':\n              options.ContentType = 'json';\n              break;\n\n            case 'text/csv':\n              options.ContentType = 'table';\n              break;\n\n            case 'text/plain':\n            case 'text/html':\n            case 'application/javascript':\n            case 'application/x-javascript':\n            case 'application/x-www-form-urlencoded':\n              options.ContentType = 'text';\n              break;\n\n            case 'text/xml':\n            case 'application/xml':\n              options.ContentType = 'xmldom';\n              break;\n\n            case 'application/octet-stream':\n              options.ContentType = 'binary';\n              break;\n\n            default:\n              if (value.startsWith('image/')) {\n                options.ContentType = 'image';\n              } else if (value.startsWith('audio/')) {\n                options.ContentType = 'audio';\n              } else {\n                headers[key] = value;\n              }\n\n          }\n\n          break;\n\n        default:\n          headers[key] = value;\n      }\n    }\n  }\n\n  if (request.cookies) {\n    headers.Cookie = cookieString;\n  }\n\n  if (Object.entries(headers).length > 0) {\n    // If key is on the same line as 'weboptions', there is only one parameter\n    // otherwise keys are indented by one level in the next line.\n    // An extra indentation level is given to the values's new lines in cell array\n    const indentLevel = 1 + (Object.keys(options).length === 0 ? 0 : 1);\n    options.HeaderFields = addCellArray(headers, ['Authorization', 'Cookie'], '', indentLevel);\n  }\n\n  return options;\n};\n\nconst prepareOptions = (request, options) => {\n  const lines = [];\n\n  if (Object.keys(options).length === 0) {\n    return lines;\n  }\n\n  const pairValues = addCellArray(options, ['HeaderFields'], ',', 1, true);\n  lines.push(callFunction('options', 'weboptions', pairValues));\n  return lines;\n};\n\nconst prepareBasicURI = request => {\n  const response = [];\n\n  if (request.query) {\n    response.push(setVariableValue('baseURI', repr(request.urlWithoutQuery)));\n    response.push(setVariableValue('uri', `[baseURI '?' ${paramsString}]`));\n  } else {\n    response.push(setVariableValue('uri', repr(request.url)));\n  }\n\n  return response;\n};\n\nconst prepareBasicData = request => {\n  let response = [];\n\n  if (request.data) {\n    if (typeof request.data === 'boolean') {\n      response = setVariableValue('body', repr());\n    } else if (request.data[0] === '@') {\n      response.push(callFunction('body', 'fileread', repr(request.data.slice(1))));\n\n      if (!request.isDataBinary) {\n        response.push(setVariableValue('body(body==13 | body==10)', '[]'));\n      }\n    } else {\n      // if the data is in JSON, store it as struct in MATLAB\n      // otherwise just keep it as a char vector\n      try {\n        const jsonData = JSON.parse(request.data);\n\n        if (typeof jsonData === 'object') {\n          let jsonText = structify(jsonData);\n          if (!jsonText.startsWith('struct')) jsonText = repr(jsonText);\n          response = setVariableValue('body', jsonText);\n        } else {\n          response = setVariableValue('body', repr(request.data));\n        }\n      } catch (e) {\n        response = setVariableValue('body', repr(request.data));\n      }\n    }\n  }\n\n  return response;\n};\n\nconst prepareWebCall = (request, options) => {\n  const lines = [];\n  const webFunction = containsBody(request) ? 'webwrite' : 'webread';\n  const params = ['uri'];\n\n  if (containsBody(request)) {\n    params.push('body');\n  }\n\n  if (Object.keys(options).length > 0) {\n    params.push('options');\n  }\n\n  lines.push(callFunction('response', webFunction, params));\n\n  if (request.query) {\n    params[0] = 'fullURI';\n    lines.push('', '% As there is a query, a full URI may be necessary instead.', setVariableValue('fullURI', repr(request.url)), callFunction('response', webFunction, params));\n  }\n\n  return lines;\n};\n\nconst toWebServices = request => {\n  let lines = ['%% Web Access using Data Import and Export API'];\n\n  if (!isSupportedByWebServices(request)) {\n    lines.push('% This is not possible with the webread/webwrite API');\n    return lines;\n  }\n\n  const options = parseWebOptions(request);\n  lines = lines.concat([prepareQueryString(request), prepareCookies(request), prepareBasicURI(request), prepareBasicData(request), prepareOptions(request, options), prepareWebCall(request, options)]);\n  return lines;\n};\n\nmodule.exports = toWebServices;","map":{"version":3,"sources":["/home/marcel/Desktop/CobaProject/GUI backless-js/axsis/node_modules/curlconverter/generators/matlab/webservices.js"],"names":["repr","setVariableValue","callFunction","addCellArray","structify","containsBody","prepareQueryString","prepareCookies","cookieString","paramsString","require","isSupportedByWebServices","request","Set","has","method","multipartUploads","insecure","parseWebOptions","options","RequestMethod","headers","auth","username","password","split","Username","Password","Authorization","key","value","Object","entries","UserAgent","MediaType","Cookie","ContentType","startsWith","cookies","length","indentLevel","keys","HeaderFields","prepareOptions","lines","pairValues","push","prepareBasicURI","response","query","urlWithoutQuery","url","prepareBasicData","data","slice","isDataBinary","jsonData","JSON","parse","jsonText","e","prepareWebCall","webFunction","params","toWebServices","concat","module","exports"],"mappings":"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","sourcesContent":["const {\n  repr, setVariableValue,\n  callFunction, addCellArray,\n  structify, containsBody,\n  prepareQueryString, prepareCookies,\n  cookieString, paramsString\n} = require('./common')\n\nconst isSupportedByWebServices = (request) => {\n  if (!new Set(['get', 'post', 'put', 'delete', 'patch']).has(request.method)) {\n    return false\n  }\n  return !request.multipartUploads && !request.insecure\n}\n\nconst parseWebOptions = (request) => {\n  const options = {}\n\n  // MATLAB uses GET in `webread` and POST in `webwrite` by default\n  // thus, it is necessary to set the method for other requests\n  if (request.method !== 'get' && request.method !== 'post') {\n    options.RequestMethod = request.method\n  }\n\n  const headers = {}\n  if (request.auth) {\n    const [username, password] = request.auth.split(':')\n    if (username !== '') {\n      options.Username = username\n      options.Password = password\n    } else {\n      headers.Authorization = `['Basic ' matlab.net.base64encode(${repr(username + ':' + password)})]`\n    }\n  }\n\n  if (request.headers) {\n    for (const [key, value] of Object.entries(request.headers)) {\n      switch (key) {\n        case 'User-Agent':\n          options.UserAgent = value\n          break\n        case 'Content-Type':\n          options.MediaType = value\n          break\n        case 'Cookie':\n          headers.Cookie = value\n          break\n        case 'Accept':\n          switch (value) {\n            case 'application/json':\n              options.ContentType = 'json'\n              break\n            case 'text/csv':\n              options.ContentType = 'table'\n              break\n            case 'text/plain':\n            case 'text/html':\n            case 'application/javascript':\n            case 'application/x-javascript':\n            case 'application/x-www-form-urlencoded':\n              options.ContentType = 'text'\n              break\n            case 'text/xml':\n            case 'application/xml':\n              options.ContentType = 'xmldom'\n              break\n            case 'application/octet-stream':\n              options.ContentType = 'binary'\n              break\n            default:\n              if (value.startsWith('image/')) {\n                options.ContentType = 'image'\n              } else if (value.startsWith('audio/')) {\n                options.ContentType = 'audio'\n              } else {\n                headers[key] = value\n              }\n          }\n          break\n        default:\n          headers[key] = value\n      }\n    }\n  }\n\n  if (request.cookies) {\n    headers.Cookie = cookieString\n  }\n\n  if (Object.entries(headers).length > 0) {\n    // If key is on the same line as 'weboptions', there is only one parameter\n    // otherwise keys are indented by one level in the next line.\n    // An extra indentation level is given to the values's new lines in cell array\n    const indentLevel = 1 + (Object.keys(options).length === 0 ? 0 : 1)\n    options.HeaderFields = addCellArray(headers, ['Authorization', 'Cookie'], '', indentLevel)\n  }\n\n  return options\n}\n\nconst prepareOptions = (request, options) => {\n  const lines = []\n  if (Object.keys(options).length === 0) {\n    return lines\n  }\n  const pairValues = addCellArray(options, ['HeaderFields'], ',', 1, true)\n  lines.push(callFunction('options', 'weboptions', pairValues))\n\n  return lines\n}\n\nconst prepareBasicURI = (request) => {\n  const response = []\n  if (request.query) {\n    response.push(setVariableValue('baseURI', repr(request.urlWithoutQuery)))\n    response.push(setVariableValue('uri', `[baseURI '?' ${paramsString}]`))\n  } else {\n    response.push(setVariableValue('uri', repr(request.url)))\n  }\n  return response\n}\n\nconst prepareBasicData = (request) => {\n  let response = []\n  if (request.data) {\n    if (typeof request.data === 'boolean') {\n      response = setVariableValue('body', repr())\n    } else if (request.data[0] === '@') {\n      response.push(callFunction('body', 'fileread', repr(request.data.slice(1))))\n\n      if (!request.isDataBinary) {\n        response.push(setVariableValue('body(body==13 | body==10)', '[]'))\n      }\n    } else {\n      // if the data is in JSON, store it as struct in MATLAB\n      // otherwise just keep it as a char vector\n      try {\n        const jsonData = JSON.parse(request.data)\n        if (typeof jsonData === 'object') {\n          let jsonText = structify(jsonData)\n          if (!jsonText.startsWith('struct')) jsonText = repr(jsonText)\n          response = setVariableValue('body', jsonText)\n        } else {\n          response = setVariableValue('body', repr(request.data))\n        }\n      } catch (e) {\n        response = setVariableValue('body', repr(request.data))\n      }\n    }\n  }\n  return response\n}\n\nconst prepareWebCall = (request, options) => {\n  const lines = []\n  const webFunction = containsBody(request) ? 'webwrite' : 'webread'\n\n  const params = ['uri']\n  if (containsBody(request)) {\n    params.push('body')\n  }\n  if (Object.keys(options).length > 0) {\n    params.push('options')\n  }\n  lines.push(callFunction('response', webFunction, params))\n\n  if (request.query) {\n    params[0] = 'fullURI'\n    lines.push('',\n      '% As there is a query, a full URI may be necessary instead.',\n      setVariableValue('fullURI', repr(request.url)),\n      callFunction('response', webFunction, params)\n    )\n  }\n  return lines\n}\n\nconst toWebServices = (request) => {\n  let lines = [\n    '%% Web Access using Data Import and Export API'\n  ]\n\n  if (!isSupportedByWebServices(request)) {\n    lines.push('% This is not possible with the webread/webwrite API')\n    return lines\n  }\n\n  const options = parseWebOptions(request)\n  lines = lines.concat([\n    prepareQueryString(request),\n    prepareCookies(request),\n    prepareBasicURI(request),\n    prepareBasicData(request),\n    prepareOptions(request, options),\n    prepareWebCall(request, options)\n  ])\n\n  return lines\n}\n\nmodule.exports = toWebServices\n"]},"metadata":{},"sourceType":"script"}