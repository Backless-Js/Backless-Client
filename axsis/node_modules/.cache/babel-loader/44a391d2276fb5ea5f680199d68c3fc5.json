{"ast":null,"code":"const cookie = require('cookie');\n\nconst yargs = require('yargs');\n\nconst URL = require('url');\n\nconst querystring = require('querystring');\n\nconst parseCurlCommand = curlCommand => {\n  // Remove newlines (and from continuations)\n  curlCommand = curlCommand.replace(/\\\\\\r|\\\\\\n/g, ''); // yargs parses -XPOST as separate arguments. just prescreen for it.\n\n  curlCommand = curlCommand.replace(/ -XPOST/, ' -X POST');\n  curlCommand = curlCommand.replace(/ -XGET/, ' -X GET');\n  curlCommand = curlCommand.replace(/ -XPUT/, ' -X PUT');\n  curlCommand = curlCommand.replace(/ -XPATCH/, ' -X PATCH');\n  curlCommand = curlCommand.replace(/ -XDELETE/, ' -X DELETE'); // Safari adds `-Xnull` if is unable to determine the request type, it can be ignored\n\n  curlCommand = curlCommand.replace(/ -Xnull/, ' ');\n  curlCommand = curlCommand.trim(); // Parse with some understanding of the meanings of flags.  In particular,\n  // boolean flags can be trouble if the URL to fetch follows immediately\n  // after, since it will be taken as an argument to the flag rather than\n  // interpreted as a positional argument.  Someone should add all the flags\n  // likely to cause trouble here.\n\n  const parsedArguments = yargs.boolean(['I', 'head', 'compressed', 'L', 'k', 'silent', 's']).alias('H', 'header').alias('A', 'user-agent').parse(curlCommand);\n  let cookieString;\n  let cookies;\n  let url = parsedArguments._[1]; // if url argument wasn't where we expected it, try to find it in the other arguments\n\n  if (!url) {\n    for (const argName in parsedArguments) {\n      if (typeof parsedArguments[argName] === 'string') {\n        if (parsedArguments[argName].indexOf('http') === 0 || parsedArguments[argName].indexOf('www.') === 0) {\n          url = parsedArguments[argName];\n        }\n      }\n    }\n  }\n\n  let headers;\n\n  if (parsedArguments.header) {\n    if (!headers) {\n      headers = {};\n    }\n\n    if (!Array.isArray(parsedArguments.header)) {\n      parsedArguments.header = [parsedArguments.header];\n    }\n\n    parsedArguments.header.forEach(header => {\n      if (header.indexOf('Cookie') !== -1) {\n        cookieString = header;\n      } else {\n        const components = header.split(/:(.*)/);\n        headers[components[0]] = components[1].trim();\n      }\n    });\n  }\n\n  if (parsedArguments['user-agent']) {\n    if (!headers) {\n      headers = {};\n    }\n\n    headers['User-Agent'] = parsedArguments['user-agent'];\n  }\n\n  if (parsedArguments.b) {\n    cookieString = parsedArguments.b;\n  }\n\n  if (parsedArguments.cookie) {\n    cookieString = parsedArguments.cookie;\n  }\n\n  let multipartUploads;\n\n  if (parsedArguments.F) {\n    multipartUploads = {};\n\n    if (!Array.isArray(parsedArguments.F)) {\n      parsedArguments.F = [parsedArguments.F];\n    }\n\n    parsedArguments.F.forEach(multipartArgument => {\n      // input looks like key=value. value could be json or a file path prepended with an @\n      const splitArguments = multipartArgument.split('=', 2);\n      const key = splitArguments[0];\n      const value = splitArguments[1];\n      multipartUploads[key] = value;\n    });\n  }\n\n  if (cookieString) {\n    const cookieParseOptions = {\n      decode: function (s) {\n        return s;\n      }\n    }; // separate out cookie headers into separate data structure\n    // note: cookie is case insensitive\n\n    cookies = cookie.parse(cookieString.replace(/^Cookie: /gi, ''), cookieParseOptions);\n  }\n\n  let method;\n\n  if (parsedArguments.X === 'POST') {\n    method = 'post';\n  } else if (parsedArguments.X === 'PUT' || parsedArguments.T) {\n    method = 'put';\n  } else if (parsedArguments.X === 'PATCH') {\n    method = 'patch';\n  } else if (parsedArguments.X === 'DELETE') {\n    method = 'delete';\n  } else if (parsedArguments.X === 'OPTIONS') {\n    method = 'options';\n  } else if ((parsedArguments.d || parsedArguments.data || parsedArguments['data-ascii'] || parsedArguments['data-binary'] || parsedArguments.F || parsedArguments.form) && !(parsedArguments.G || parsedArguments.get)) {\n    method = 'post';\n  } else if (parsedArguments.I || parsedArguments.head) {\n    method = 'head';\n  } else {\n    method = 'get';\n  }\n\n  const compressed = !!parsedArguments.compressed;\n  const urlObject = URL.parse(url); // eslint-disable-line\n  // if GET request with data, convert data to query string\n  // NB: the -G flag does not change the http verb. It just moves the data into the url.\n\n  if (parsedArguments.G || parsedArguments.get) {\n    urlObject.query = urlObject.query ? urlObject.query : '';\n    const option = 'd' in parsedArguments ? 'd' : 'data' in parsedArguments ? 'data' : null;\n\n    if (option) {\n      let urlQueryString = '';\n\n      if (url.indexOf('?') < 0) {\n        url += '?';\n      } else {\n        urlQueryString += '&';\n      }\n\n      if (typeof parsedArguments[option] === 'object') {\n        urlQueryString += parsedArguments[option].join('&');\n      } else {\n        urlQueryString += parsedArguments[option];\n      }\n\n      urlObject.query += urlQueryString;\n      url += urlQueryString;\n      delete parsedArguments[option];\n    }\n  }\n\n  const query = querystring.parse(urlObject.query, null, null, {\n    maxKeys: 10000\n  });\n  urlObject.search = null; // Clean out the search/query portion.\n\n  const request = {\n    url: url,\n    urlWithoutQuery: URL.format(urlObject)\n  };\n\n  if (compressed) {\n    request.compressed = true;\n  }\n\n  if (Object.keys(query).length > 0) {\n    request.query = query;\n  }\n\n  if (headers) {\n    request.headers = headers;\n  }\n\n  request.method = method;\n\n  if (cookies) {\n    request.cookies = cookies;\n    request.cookieString = cookieString.replace('Cookie: ', '');\n  }\n\n  if (multipartUploads) {\n    request.multipartUploads = multipartUploads;\n  }\n\n  if (parsedArguments.data) {\n    request.data = parsedArguments.data;\n  } else if (parsedArguments['data-binary']) {\n    request.data = parsedArguments['data-binary'];\n    request.isDataBinary = true;\n  } else if (parsedArguments.d) {\n    request.data = parsedArguments.d;\n  } else if (parsedArguments['data-ascii']) {\n    request.data = parsedArguments['data-ascii'];\n  }\n\n  if (parsedArguments.u) {\n    request.auth = parsedArguments.u;\n  }\n\n  if (parsedArguments.user) {\n    request.auth = parsedArguments.user;\n  }\n\n  if (Array.isArray(request.data)) {\n    request.dataArray = request.data;\n    request.data = request.data.join('&');\n  }\n\n  if (parsedArguments.k || parsedArguments.insecure) {\n    request.insecure = true;\n  }\n\n  return request;\n};\n\nconst serializeCookies = cookieDict => {\n  let cookieString = '';\n  let i = 0;\n  const cookieCount = Object.keys(cookieDict).length;\n\n  for (const cookieName in cookieDict) {\n    const cookieValue = cookieDict[cookieName];\n    cookieString += cookieName + '=' + cookieValue;\n\n    if (i < cookieCount - 1) {\n      cookieString += '; ';\n    }\n\n    i++;\n  }\n\n  return cookieString;\n};\n\nmodule.exports = {\n  parseCurlCommand: parseCurlCommand,\n  serializeCookies: serializeCookies\n};","map":{"version":3,"sources":["/home/marcel/Desktop/CobaProject/GUI backless-js/axsis/node_modules/curlconverter/util.js"],"names":["cookie","require","yargs","URL","querystring","parseCurlCommand","curlCommand","replace","trim","parsedArguments","boolean","alias","parse","cookieString","cookies","url","_","argName","indexOf","headers","header","Array","isArray","forEach","components","split","b","multipartUploads","F","multipartArgument","splitArguments","key","value","cookieParseOptions","decode","s","method","X","T","d","data","form","G","get","I","head","compressed","urlObject","query","option","urlQueryString","join","maxKeys","search","request","urlWithoutQuery","format","Object","keys","length","isDataBinary","u","auth","user","dataArray","k","insecure","serializeCookies","cookieDict","i","cookieCount","cookieName","cookieValue","module","exports"],"mappings":"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","sourcesContent":["const cookie = require('cookie')\nconst yargs = require('yargs')\nconst URL = require('url')\nconst querystring = require('querystring')\n\nconst parseCurlCommand = curlCommand => {\n  // Remove newlines (and from continuations)\n  curlCommand = curlCommand.replace(/\\\\\\r|\\\\\\n/g, '')\n\n  // yargs parses -XPOST as separate arguments. just prescreen for it.\n  curlCommand = curlCommand.replace(/ -XPOST/, ' -X POST')\n  curlCommand = curlCommand.replace(/ -XGET/, ' -X GET')\n  curlCommand = curlCommand.replace(/ -XPUT/, ' -X PUT')\n  curlCommand = curlCommand.replace(/ -XPATCH/, ' -X PATCH')\n  curlCommand = curlCommand.replace(/ -XDELETE/, ' -X DELETE')\n  // Safari adds `-Xnull` if is unable to determine the request type, it can be ignored\n  curlCommand = curlCommand.replace(/ -Xnull/, ' ')\n  curlCommand = curlCommand.trim()\n\n  // Parse with some understanding of the meanings of flags.  In particular,\n  // boolean flags can be trouble if the URL to fetch follows immediately\n  // after, since it will be taken as an argument to the flag rather than\n  // interpreted as a positional argument.  Someone should add all the flags\n  // likely to cause trouble here.\n  const parsedArguments = yargs\n    .boolean(['I', 'head', 'compressed', 'L', 'k', 'silent', 's'])\n    .alias('H', 'header')\n    .alias('A', 'user-agent')\n    .parse(curlCommand)\n\n  let cookieString\n  let cookies\n  let url = parsedArguments._[1]\n\n  // if url argument wasn't where we expected it, try to find it in the other arguments\n  if (!url) {\n    for (const argName in parsedArguments) {\n      if (typeof parsedArguments[argName] === 'string') {\n        if (parsedArguments[argName].indexOf('http') === 0 || parsedArguments[argName].indexOf('www.') === 0) {\n          url = parsedArguments[argName]\n        }\n      }\n    }\n  }\n\n  let headers\n\n  if (parsedArguments.header) {\n    if (!headers) {\n      headers = {}\n    }\n    if (!Array.isArray(parsedArguments.header)) {\n      parsedArguments.header = [parsedArguments.header]\n    }\n    parsedArguments.header.forEach(header => {\n      if (header.indexOf('Cookie') !== -1) {\n        cookieString = header\n      } else {\n        const components = header.split(/:(.*)/)\n        headers[components[0]] = components[1].trim()\n      }\n    })\n  }\n\n  if (parsedArguments['user-agent']) {\n    if (!headers) {\n      headers = {}\n    }\n    headers['User-Agent'] = parsedArguments['user-agent']\n  }\n\n  if (parsedArguments.b) {\n    cookieString = parsedArguments.b\n  }\n  if (parsedArguments.cookie) {\n    cookieString = parsedArguments.cookie\n  }\n  let multipartUploads\n  if (parsedArguments.F) {\n    multipartUploads = {}\n    if (!Array.isArray(parsedArguments.F)) {\n      parsedArguments.F = [parsedArguments.F]\n    }\n    parsedArguments.F.forEach(multipartArgument => {\n      // input looks like key=value. value could be json or a file path prepended with an @\n      const splitArguments = multipartArgument.split('=', 2)\n      const key = splitArguments[0]\n      const value = splitArguments[1]\n      multipartUploads[key] = value\n    })\n  }\n  if (cookieString) {\n    const cookieParseOptions = {\n      decode: function (s) { return s }\n    }\n    // separate out cookie headers into separate data structure\n    // note: cookie is case insensitive\n    cookies = cookie.parse(cookieString.replace(/^Cookie: /gi, ''), cookieParseOptions)\n  }\n  let method\n  if (parsedArguments.X === 'POST') {\n    method = 'post'\n  } else if (parsedArguments.X === 'PUT' ||\n    parsedArguments.T) {\n    method = 'put'\n  } else if (parsedArguments.X === 'PATCH') {\n    method = 'patch'\n  } else if (parsedArguments.X === 'DELETE') {\n    method = 'delete'\n  } else if (parsedArguments.X === 'OPTIONS') {\n    method = 'options'\n  } else if ((parsedArguments.d ||\n    parsedArguments.data ||\n    parsedArguments['data-ascii'] ||\n    parsedArguments['data-binary'] ||\n    parsedArguments.F ||\n    parsedArguments.form) && !((parsedArguments.G || parsedArguments.get))) {\n    method = 'post'\n  } else if (parsedArguments.I ||\n    parsedArguments.head) {\n    method = 'head'\n  } else {\n    method = 'get'\n  }\n\n  const compressed = !!parsedArguments.compressed\n  const urlObject = URL.parse(url); // eslint-disable-line\n\n  // if GET request with data, convert data to query string\n  // NB: the -G flag does not change the http verb. It just moves the data into the url.\n  if (parsedArguments.G || parsedArguments.get) {\n    urlObject.query = urlObject.query ? urlObject.query : ''\n    const option = 'd' in parsedArguments ? 'd' : 'data' in parsedArguments ? 'data' : null\n    if (option) {\n      let urlQueryString = ''\n\n      if (url.indexOf('?') < 0) {\n        url += '?'\n      } else {\n        urlQueryString += '&'\n      }\n\n      if (typeof (parsedArguments[option]) === 'object') {\n        urlQueryString += parsedArguments[option].join('&')\n      } else {\n        urlQueryString += parsedArguments[option]\n      }\n      urlObject.query += urlQueryString\n      url += urlQueryString\n      delete parsedArguments[option]\n    }\n  }\n  const query = querystring.parse(urlObject.query, null, null, { maxKeys: 10000 })\n\n  urlObject.search = null // Clean out the search/query portion.\n  const request = {\n    url: url,\n    urlWithoutQuery: URL.format(urlObject)\n  }\n  if (compressed) {\n    request.compressed = true\n  }\n\n  if (Object.keys(query).length > 0) {\n    request.query = query\n  }\n  if (headers) {\n    request.headers = headers\n  }\n  request.method = method\n\n  if (cookies) {\n    request.cookies = cookies\n    request.cookieString = cookieString.replace('Cookie: ', '')\n  }\n  if (multipartUploads) {\n    request.multipartUploads = multipartUploads\n  }\n  if (parsedArguments.data) {\n    request.data = parsedArguments.data\n  } else if (parsedArguments['data-binary']) {\n    request.data = parsedArguments['data-binary']\n    request.isDataBinary = true\n  } else if (parsedArguments.d) {\n    request.data = parsedArguments.d\n  } else if (parsedArguments['data-ascii']) {\n    request.data = parsedArguments['data-ascii']\n  }\n\n  if (parsedArguments.u) {\n    request.auth = parsedArguments.u\n  }\n  if (parsedArguments.user) {\n    request.auth = parsedArguments.user\n  }\n  if (Array.isArray(request.data)) {\n    request.dataArray = request.data\n    request.data = request.data.join('&')\n  }\n\n  if (parsedArguments.k || parsedArguments.insecure) {\n    request.insecure = true\n  }\n  return request\n}\n\nconst serializeCookies = cookieDict => {\n  let cookieString = ''\n  let i = 0\n  const cookieCount = Object.keys(cookieDict).length\n  for (const cookieName in cookieDict) {\n    const cookieValue = cookieDict[cookieName]\n    cookieString += cookieName + '=' + cookieValue\n    if (i < cookieCount - 1) {\n      cookieString += '; '\n    }\n    i++\n  }\n  return cookieString\n}\n\nmodule.exports = {\n  parseCurlCommand: parseCurlCommand,\n  serializeCookies: serializeCookies\n}\n"]},"metadata":{},"sourceType":"script"}